<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer题解02-10]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A302-10%2F</url>
    <content type="text"><![CDATA[02 单例模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 从具体实现角度来说，主要有三点：一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 懒汉式-线程不安全public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125;// 双重校验锁-线程安全public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125;// 静态内部类实现public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 03 数组中重复的数字12345678910111213141516171819202122232425/** * 03 数组中重复的数字 * 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道 有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 */public class _03 &#123; public static boolean duplicate(int[] numbers,int length,int[] duplication) &#123; int [] array = new int[length]; for (int i = 0; i &lt; length; ++i) &#123; if (array[numbers[i]] == 0) &#123; array[numbers[i]] = 1; &#125; else &#123; duplication[0] =numbers[i]; return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int[] numbers = &#123;2, 3, 1, 0, 2, 5, 3&#125;; int[] duplication = new int[1]; System.out.println(duplicate(numbers, numbers.length, duplication) + " " + duplication[0]); &#125;&#125; 04 二维数组中的查找12345678910111213141516171819202122232425262728293031323334/** * 04 二维数组中的查找 * 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 */public class _04 &#123; public static boolean find(int target, int [][] array) &#123; if (array == null || array.length == 0) &#123; return false; &#125; if (array[0].length == 0) &#123; return false; &#125; int col = array[0].length; int row = array.length; int i = row - 1; int j = 0; while (j &lt; col &amp;&amp; i &gt;= 0) &#123; if (array[i][j] == target) &#123; return true; &#125; else if (array[i][j] &gt; target) &#123; i--; &#125; else &#123; j++; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int[][] array = &#123;&#123;1, 4, 7, 11, 15&#125;, &#123;2, 5, 8, 12, 19&#125;&#125;; System.out.println("Find(5, array) = " + find(5, array)); &#125;&#125; 05 替换空格123456789101112131415161718192021222324252627282930313233343536/** * 05 替换空格 * 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过 替换之后的字符串为We%20Are%20Happy。 * * 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符 （%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。 * 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。 * 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容 */public class _05 &#123; public static String replaceSpace(StringBuffer str) &#123; int originalLength = str.length(); for (int i = 0; i &lt; originalLength; ++i) &#123; if (str.charAt(i) == ' ') &#123; // 每遇到一个空格扩充2个长度 str.append(" "); &#125; &#125; int newLength = str.length(); int j = newLength - 1; for (int i = originalLength - 1; i &gt;= 0; --i) &#123; if (str.charAt(i) == ' ') &#123; str.setCharAt(j--, '0'); str.setCharAt(j--, '2'); str.setCharAt(j--, '%'); &#125; else &#123; str.setCharAt(j--, str.charAt(i)); &#125; &#125; return str.toString(); &#125; public static void main(String[] args) &#123; replaceSpace(new StringBuffer("We Are Happy")); &#125;&#125; 06 从头到尾打印链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.ArrayList;import java.util.List;import java.util.Stack;/** * 06 从头到尾打印链表 * 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 *//** * public class ListNode &#123; * int val; * ListNode next = null; * * ListNode(int val) &#123; * this.val = val; * &#125; * &#125; * */public class _06 &#123; /** * 使用堆栈 * @param listNode 链表头结点 * @return 反向打印所有值 */ public static ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode == null) &#123; return new ArrayList&lt;&gt;(); &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; while (!stack.empty()) &#123; arrayList.add(stack.pop()); &#125; return arrayList; &#125; /** * 使用递归 * @param listNode 链表头结点 * @return 反向打印所有值 */ public static ArrayList&lt;Integer&gt; printListFromTailToHead1(ListNode listNode) &#123; if (listNode == null) &#123; return new ArrayList&lt;&gt;(); &#125; ArrayList&lt;Integer&gt; arrayList = printListFromTailToHead1(listNode.next); arrayList.add(listNode.val); return arrayList; &#125; /** * 使用头插法 * 构建一个头指针head，初始head-&gt;next = null，然后不断将listNode中的节点加到head后 面，相当于反向链表 * @param listNode 链表头结点 * @return 反向打印所有值 */ public static ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) &#123; if (listNode == null) &#123; return new ArrayList&lt;&gt;(); &#125; // 头指针 ListNode head = new ListNode(0); head.next = null; // 将listNode中的结点逐步加到head后面 while (listNode != null) &#123; // 先存储下一个结点 ListNode nextNode = listNode.next; // 头插 listNode.next = head.next; head.next = listNode; // 继续下一次循环 listNode = nextNode; &#125; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); // 头结点 listNode = head.next; while (listNode != null) &#123; arrayList.add(listNode.val); listNode = listNode.next; &#125; return arrayList; &#125; public static void main(String[] args) &#123; // 构造一个链表 ListNode listNode1 = new ListNode(1); ListNode listNode2 = new ListNode(2); listNode2.next = null; listNode1.next = listNode2; List&lt;Integer&gt; list = printListFromTailToHead2(listNode1); for (Integer integer : list) &#123; System.out.println(integer + " "); &#125; &#125; /** * 内部类：相当于一个链表节点 */ public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 07 重建二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 07 重建二叉树 * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结 果中都不含重复的数字。例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。 * 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序 遍历结果，右部分为树的右子树中序遍历的结果,然后就可以接着分别对左右子树递归下去。 *//** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class _07 &#123; /** * 重建二叉树 * @param pre 前序遍历 * @param in 中序遍历 * @return 返回重建的二叉树 */ public static TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if (pre == null || in == null || pre.length == 0 || in.length == 0) &#123; return null; &#125; return reConstructBinaryTree(pre, in, 0, pre.length - 1, 0, in.length - 1); &#125; /** * 扩充前序与中序的索引参数，便于递归重建二叉树 * @param pre 前序遍历 * @param in 中序遍历 * @param preStart 前序遍历数组的开始索引 * @param preEnd 前序遍历数组的结束索引 * @param inStart 中序遍历数组的开始索引 * @param inEnd 中序遍历数组的结束索引 * @return 返回重建的二叉树 */ private static TreeNode reConstructBinaryTree(int [] pre,int [] in, int preStart, int preEnd, int inStart, int inEnd) &#123; if (preStart &gt; preEnd) &#123; return null; &#125; // 根节点的值是前序遍历的第一个值 int rootValue = pre[preStart]; TreeNode treeNode = new TreeNode(rootValue); // 找到中序遍历序列中的根节点的位置，递归得到左右节点 for (int i = inStart; i &lt;= inEnd; ++i) &#123; if (in[i] == pre[preStart]) &#123; treeNode.left = reConstructBinaryTree(pre, in, preStart + 1, preStart + i - inStart, inStart, i - 1); treeNode.right = reConstructBinaryTree(pre, in, preStart + i - inStart + 1, preEnd, i + 1, inEnd); break; &#125; &#125; return treeNode; &#125; public static void main(String[] args) &#123; int[] pre = &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; int[] in = &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; reConstructBinaryTree(pre, in); &#125; /** * 内部类：二叉树结构 */ public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;&#125; 08 二叉树的下一个结点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 08 二叉树的下一个结点 * 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不 仅包含左右子结点，同时包含指向父结点的指针 * 分三种情况： * （1）当前节点有右子树，则下一个中序遍历节点是右子树中的最左节点 * （2）当前节点没有右子树，且该节点是其父节点的左节点，则下一个节点是其父节点 * （3）当前节点没有右子树，且该节点是其父节点的右节点，则沿着其父节点向上遍历，直到找到一个 是其父节点的左节点的节点，这个节点的父节点即为所求 *//** public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125; &#125;*/public class _08 &#123; public static TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) &#123; return null; &#125; // 当前节点有右子树 if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; // 当前节点没有右子树，且该节点没有父节点，是根节点 if (pNode.next == null) &#123; return null; &#125; // 当前节点没有右子树，且该节点是其父节点的左节点 if (pNode.next.left == pNode) &#123; return pNode.next; &#125; // 当前节点没有右子树，且该节点是其父节点的右节点 if (pNode.next.right == pNode) &#123; pNode = pNode.next; while (pNode.next != null) &#123; if (pNode.next.left != pNode) &#123; pNode = pNode.next; &#125; else &#123; return pNode.next; &#125; &#125; &#125; return null; &#125; /** * 二叉树结构，包含了指向其父节点的指针 */ public static class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125; &#125;&#125; 09 用两个栈实现队列12345678910111213141516171819202122232425262728293031323334353637import java.util.Stack;/** * 09 用两个栈实现队列 * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型 * 栈1的push对应队列的deleteHead操作，栈2的pop操作对应队列的insertTail操作，当栈2为空时， 将栈1的元素依次出栈，进到栈2中，如果栈1也为空，则提示队列为空 */public class _09 &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); /** * 队列的insertTail操作 * @param node 插入队尾的元素 */ public void push(int node) &#123; stack1.push(node); &#125; /** * 队列的deleteHead操作 * @return 删除队列头部 */ public int pop() &#123; if (stack2.empty()) &#123; if (stack1.empty()) &#123; throw new RuntimeException("队列为空"); &#125; else &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; &#125; return stack2.pop(); &#125;&#125; 10 斐波那契数列1234567891011121314151617181920212223242526/** * 10 斐波那契数列 * 大家都知道斐波那契数列，后一项等于前两项和，现在要求输入一个整数n，请你输出斐波那契数列的 第n项（从0开始，第0项为0，n&lt;=39）。 * 使用两个数将结果前两项缓存即可 */public class _10 &#123; public static int Fibonacci(int n) &#123; int result = 0; int temp1 = 0; int temp2 = 1; if (n == 1) &#123; return temp2; &#125; for (int i = 1; i &lt; n; i++) &#123; result = temp1 + temp2; temp1 = temp2; temp2 = result; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println("Fibonacci(3) = " + Fibonacci(3)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA整合SSM框架]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BD%BF%E7%94%A8IDEA%E6%95%B4%E5%90%88SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、安装环境和开发工具在整合Spring，SpringMVC 和 MyBatis 的过程中，很容易遇到一些小问题，因此记录下整合过程。 首先是安装环境和开发工具，如下： Window 7 Jdk 1.8 MySql 8.0 Maven 3.5.4 Tomcat 8.5.34 IntelliJ IDEA 2018 二、整体项目结构整个项目在Maven WebApp模板工程的基础上构建，不同类型的文件放置于不同的包或者路径下，全部配置完成后的工程结构如下图所示： 不同路径下的文件归类说明如下表(classpath相当于resources文件夹)： 包名/路径名 作用 controller 存放控制器 mapper DAO层接口 pojo 实体类 service 业务类（接口+实现） /com/cr/mapper 对应mapper下接口的xml文件 /spring 与spring相关的配置文件 /webapp/jsp 存放jsp文件 /*.properties 资源文件 三、配置步骤1、添加Maven依赖 新建一个Maven WebApp工程，在pom.xml添加依赖，主要包括spring、springmvc、 mybatis、mybatis-spring 、servlet 、mysql 等项的jar包。 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cr&lt;/groupId&gt; &lt;artifactId&gt;SSMTest&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSMTest Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.9.3&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--添加Spring MVC的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加Servlet的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--JSTL用于在控制器中将模型绑定到JSP中--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加spring的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--利用它处理事务问题--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加数据库Mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--驱动版本号一定要装正确 否则连不上 mysql 5.1.46 可以适用本机--&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加Mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合Mybatis与Spring的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis分页依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 处理时间日期格式 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 用于MD5加密 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加Json依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--有时候不加可能会报错--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;!-- 新添加处理json为java bean --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传 高版本可以使用Multipart解析器 就不用引入这个包了 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源的引入， 池化技术 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSMTest&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 添加完成后的maven依赖如下： 2、配置web.xml spring上下文文件路径配置 12345&lt;!--配置Spring IoC的配置文件路径 classpath相当于resources文件夹--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 这里指定了上下文配置文件为spring文件夹下的applicationContext.xml，稍后再配置这个文件。 Log4j配置 1234&lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;60000&lt;/param-value&gt;&lt;/context-param&gt; ContextLoaderListener监听器配置 1234567&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 防止Spring内存溢出监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;&lt;/listener&gt; DispatcherServlet前置控制器配置 1234567891011&lt;servlet&gt; &lt;!--springmvc框架默认自动找到/WEB-INF/springmvc-servlet.xml作为配置文件载入web工程中 这里手动设置位置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt; springmvc框架默认自动找到/WEB-INF/[servlet-name]-servlet.xml作为配置文件载入web工程中 这里手动设置位置为spring文件夹下的springmvc-servlet.xml，稍后再配置这个文件。 Servlet拦截设置 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- Spring配置 --&gt; &lt;!-- ================================================= --&gt; &lt;!--配置Spring IoC的配置文件路径 classpath相当于resources文件夹--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Log4j配置--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;60000&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置ContextLoaderListener初始化IOC容器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring mvc配置 --&gt; &lt;!-- ================================================= --&gt; &lt;!--DispatcherServlet前置控制器配置--&gt; &lt;servlet&gt; &lt;!--springmvc框架默认自动找到/WEB-INF/springmvc-servlet.xml作为配置文件载入web工程中 这里手动设置位置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;!--拦截内容：servlet映射设置--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3、applicationContext.xml配置 在spring文件夹下建立applicationContext.xml applicationContext.xml 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--引入spring和其他整合的配置文件 比如spring-mybatis.xml等--&gt; &lt;import resource="classpath:spring/spring-*.xml"/&gt;&lt;/beans&gt; 这里引入spring和其他整合的配置文件 比如spring-mybatis.xml等，接下来在spring文件夹下新建一个spring-mybatis.xml文件 4、spring-mybatis.xml配置 配置自动扫描，需要扫描到控制层和服务层，刚开始我这里写成了com.cr.mapper，结果导致控制器不能注入 1&lt;context:component-scan base-package="com.cr" /&gt; 新建数据库资源文件jdbc.properties，针对不同的数据库需要修改配置 同时要注意匹配数据库的版本号，比如我安装的是MySQL 8.0，之前由于驱动版本弄错了，所以总是连接数据库失败，后来改成5.1.46才解决了问题 12345678910111213141516# 针对不同的数据库需要修改配置 同时要注意匹配数据库的版本号mysql.driver=com.mysql.jdbc.Drivermysql.url=jdbc:mysql://localhost:3306/mybatismysql.username=rootmysql.password=XXXX#定义初始连接数dbcp.initialSize=0#定义最大连接数dbcp.maxActive=20#定义最大空闲dbcp.maxIdle=20#定义最小空闲dbcp.minIdle=1#定义最长等待时间dbcp.maxWait=60000 引入数据库资源文件 1234&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt;&lt;/bean&gt; 配置数据库MySQL 12345678910111213&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;mysql.driver&#125;" /&gt; &lt;property name="url" value="$&#123;mysql.url&#125;" /&gt; &lt;property name="username" value="$&#123;mysql.username&#125;" /&gt; &lt;property name="password" value="$&#123;mysql.password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;dbcp.initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;dbcp.maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;dbcp.maxIdle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;dbcp.minIdle&#125;" /&gt; &lt;property name="maxWait" value="$&#123;dbcp.maxWait&#125;" /&gt;&lt;/bean&gt; 整合Spring和MyBatis，注意路径的书写方式是”/“不是”.” 1234567891011&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 注意路径是"/"不是"."--&gt; &lt;property name="mapperLocations" value="classpath:com/cr/mapper/*.xml" /&gt; &lt;property name="configuration"&gt; &lt;!--可以将之前mybatis.cfg.xml的一些配置项转移到这里来--&gt; &lt;bean class="org.apache.ibatis.session.Configuration"&gt; &lt;property name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 扫描持久层接口 1234&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.cr.mapper" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;/bean&gt; 数据库事务管理 1234&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; spring-mybatis.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 自动扫描包 包括了控制层和服务层 --&gt; &lt;context:component-scan base-package="com.cr" /&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;mysql.driver&#125;" /&gt; &lt;property name="url" value="$&#123;mysql.url&#125;" /&gt; &lt;property name="username" value="$&#123;mysql.username&#125;" /&gt; &lt;property name="password" value="$&#123;mysql.password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;dbcp.initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;dbcp.maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;dbcp.maxIdle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;dbcp.minIdle&#125;" /&gt; &lt;property name="maxWait" value="$&#123;dbcp.maxWait&#125;" /&gt; &lt;/bean&gt; &lt;!-- 整合Spring和MyBatis，就不需要之前的mybatis配置文件了 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 注意路径是"/"不是"."--&gt; &lt;property name="mapperLocations" value="classpath:com/cr/mapper/*.xml" /&gt; &lt;property name="configuration"&gt; &lt;!--可以将之前mybatis.cfg.xml的一些配置项转移到这里来--&gt; &lt;bean class="org.apache.ibatis.session.Configuration"&gt; &lt;property name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描DAO持久层接口 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.cr.mapper" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 数据库事务管理 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt;&lt;/beans&gt; 5、springmvc-servlet.xml配置 springmvc-servlet.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"&gt; &lt;!-- scan the package and the sub package --&gt; &lt;context:component-scan base-package="com.cr.controller"/&gt; &lt;!-- don't handle the static resource --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- if you use annotation you must configure following setting --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- configure the InternalResourceViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"&gt; &lt;!--相当于寻找/jsp/xxx.jsp文件--&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/jsp/" /&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 6、建立实体类 在pojo包下新建一个实体User类，包含用户名username 和 密码password 字段，alt + insert 生成 setter和getter方法 User.java 1234567891011121314151617181920212223package com.cr.pojo;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 7、DAO层建立 创建测试用表t_user，并添加两条数据 在mapper包下新建一个UserMapper接口，包含一个select查询方法，可以查询用户是否存在，若不存在返回null UserMapper.java 1234567package com.cr.mapper;import com.cr.pojo.User;public interface UserMapper &#123; User select(User user);&#125; 创建UserMapper和mybatis映射文件 UserMapper.xml，路径是resource/com/cr/mapper UserMapper.xml 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.cr.mapper.UserMapper"&gt; &lt;select id="select" parameterType="com.cr.pojo.User" resultType="com.cr.pojo.User"&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 8、服务层建立 建立UserService接口，位于service包下 UserService.java 12345678910package com.cr.service;import com.cr.pojo.User;public interface UserService &#123; /** * 根据user信息检查数据库中是否存在该用户 */ User get(User user);&#125; 在service包下建立impl子包，添加实现类UserServiceImpl UserServiceImpl.java 1234567891011121314151617181920package com.cr.service.impl;import com.cr.mapper.UserMapper;import com.cr.pojo.User;import com.cr.service.UserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;// @Service用于业务层 功能等同于@component@Service("userService")public class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override public User get(User user) &#123; // 通过Mapper的select方法查询用户 return userMapper.select(user); &#125;&#125; 9、建立控制器 在controller包下建立控制器UserController，根据表单的用户名和密码，在数据中匹配，如果存在该用户，则跳转到登录成功界面user.jsp，如果用户不存在则返回null，重定向回登录界面，以便于重新登录。 UserController.java 1234567891011121314151617181920212223242526272829303132333435package com.cr.controller;import com.cr.pojo.User;import com.cr.service.UserService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;// spring-mybatis.xml和springmvc-servlet.xml都配置了扫描控制层@Controllerpublic class UserController &#123; // 注入UserService @Resource private UserService userService; @RequestMapping(value = "/login") public String login(User user) &#123; ModelAndView mv = new ModelAndView(); System.out.println("开始查询---"); user = userService.get(user); if (user != null) &#123; System.out.println("查到的User: " + user.getUsername()); mv.addObject("user", user); // 转到user.jsp用户界面 return "user"; &#125; else &#123; System.out.println("未查到此用户"); // 查不到用户信息，则重定向回登录界面 System.out.println("重定向回登录界面---"); return "login"; &#125; &#125;&#125; 10、建立Jsp页面 login.jsp 123456789101112131415161718192021222324252627282930&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户登录界面&lt;/h1&gt;&lt;h2&gt;用户信息&lt;/h2&gt;&lt;h3&gt;Tom 123&lt;/h3&gt;&lt;h3&gt;Jack 456&lt;/h3&gt;&lt;br&gt;&lt;form id="form" action="/login" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input id="username" name="username" value="" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input id="password-always-checkbox" name="password" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align="right"&gt;&lt;input type="submit" value="提交"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; user.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;User&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户登录成功&lt;/h1&gt;&lt;br&gt;欢迎您: $&#123;user&#125;&lt;/body&gt;&lt;/html&gt; 四、部署项目1、Tomcat配置 2、启动服务器 浏览器访问http://localhost:8080/login 填写错误的用户名或者密码，浏览器将重新返回登录界面，控制台显示如下： 填写正确的用户名Tom和密码123，跳转到登录成功界面user.jsp，显示如下： 以上说明SSM框架整合成功。项目下载地址：https://github.com/wychencr/SSM-Test 五、一些注意事项 MySQL的驱动要匹配本机安装的版本 resources文件夹要被标记为Resource Root xml配置文件中的classpath相当于/resources IDEA可能会提示上下文配置文件没有添加，只要打开工程结构选项，把当前xml文件添加到工程中即可 注意各个xml配置文件中扫描包的位置，如果有遗漏就会报错 注意各个jar包的版本问题，我原来使用最新的Mybatis 3.4.6就会出现报错 java.lang.IllegalAccessError: org.apache.commons.dbcp.DelegatingPreparedStatement.isClosed() 修改版本为3.2.6后解决问题]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绑定个人域名与Github pages]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%B8%8EGithub-pages%2F</url>
    <content type="text"><![CDATA[一、申请个人域名本文承接 使用Hexo和Github建立个人主页 当我们使用Hexo在github pages上部署好个人页面后，就可以通过username.github.io访问了，接下来要做的就是申请一个属于自己的域名，然后将域名与上述的网址绑定起来，这样就可以通过个人域名来访问自己个人站点了。 1、申请来源 国内服务商我们可以阿里云或者腾讯云，国外服务商可以选择GoDaddy，支持支付宝支付。 申请的域名根据珍惜程度，或者域名使用时间，需要收取不同的费用。对于个人域名来说，腾讯云或者阿里云上面的活动价格每年最低只要几元。 freenom 是一个可以申请免费域名的网站，在freenom上面可以申请到免费的顶级域名.tk .ml .ga .cf .gq 。 2、顶级域名参考自3分钟弄明白顶级域名二级域名子域名父域名的区别 顶级域名 Top-level domains，first-level domains（TLDs） :是互联网DNS等级之中的最高级的域，保存于DNS根域的名字空间中。顶级域名是域名的最后一个部分，即是域名最后一点之后的字母，比如常见的.com 顶级域名分为4类 通用顶级域 ：如”.com”、”.net”、”.org”、”.edu”、”.info”等，均由国外公司负责管理 国家及地区顶级域 ：如”.cn”代表中国，”.uk”代表英国等，地理顶级域名一般由各个国家或地区负责管理。 基础建设顶级域 测试顶级域 比如上述的.tk域名是南太平洋岛国托克劳的顶级域名, .ml 是非洲国家马里的后缀, .ga 域名为加蓬国家顶级域名后缀, .cf 是中非共和国的后缀, .gq域名是赤道几内亚国家地区顶级域名。 3、注册freenom freenom的官方网站 这个网站一般都不是很稳定，建议使用vpn登入，首先要注册一个账号，直接使用谷歌邮箱注册即可，使用国内的邮箱应该不可以，收不到邮件验证码。 4、检索域名在首页的搜索框中，输入自己想申请的域名名称，点击检查可用性按钮，可以看到前面几个免费的顶级域名 点击现在获取按钮，加入购物车 Period 选择12个月免费，如果超过12个月就需要收费了。 当域名快到期时，freenom会发邮件提醒，可以直接再续期一年。 然后点击Continue按钮。 在Review &amp; Checkout界面，填写一些基本信息，点击complete order即可。 这样一个属于自己域名就申请并购买完成了。 值得注意的是，这些申请的免费域名不需要备案，对搜索引擎的友好度也不高，并且不算稳定，可能会被freenom突然收回，如果需要稳定性，建议选择付费域名。 二、freenom域名解析1、设置DNS进入我的域名界面，点击Manage Domain按钮 点击Manage Freenom DNS按钮 添加两条记录，按照如下设置即可。 1234Name: 空/wwwType: CNAMETTL: 14440(默认)Target: &lt;username&gt;.github.io 网上很多说法都是使用A类型解析，需要填写github的ip地址或者ping自己username.github.io的IP地址，我经过测试，只需要填写CNAME解析即可。 相关参数的含义如下： 2、关联github pages登录github，进入username.github.io这个仓库，点击Setting，往下翻，找到github pages的设置项。 在自定义域名栏输入刚刚申请到的域名名称，不需要加http或https前缀，点击Save即可。 刷新后，进入仓库，可以看到多了一个CNAME文件，里面的内容就是我们的域名名称。 大约等10分钟后，就可以通过域名访问到我们的个人站点了。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>freenom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用的常用命令]]></title>
    <url>%2F2018%2F10%2F19%2FGit%E4%BD%BF%E7%94%A8-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、git工作流程 Workspace工作区：是当前工作目录，可以在此目录编辑文件 Index缓存区：add指令，保存文件的改动 Repository仓库：commit指令，将多次的文件改动最后提交 Remote远程仓库：可以将本地仓库代码传到远程仓库上，方便多人远程协作 二、常用操作1、初始化仓库1$ git init 2、加到缓存区12345678# 指定文件，提交到暂存区$ git add &lt;filename&gt;# 将工作区的变化提交到暂存区，包括文件修改和新增，但是不包括删除的文件$ git add .# 将工作区的变化提交到暂存区，包括新增，删除和修改的所有内容$ git add -A 3、提交到版本库12# 将修改从暂存区提交到版本库，并添加备注message$ git commit -m “message” 4、查看信息123456789101112131415161718# 查看上次提交之后是否有修改$ git status# 查看上次提交之后是否有修改，简短输出结果$ git status -s# 查看尚未缓存的改动$ git diff# 查看已缓存的改动$ git diff -cached# 查看已缓存的与未缓存的所有改动$ git diff HEAD# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示指定文件相关的每一次diff$ git log -p [file] 5、回退操作1234567891011121314# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard 6、分支操作123456789101112131415161718192021222324252627282930# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 7、克隆仓库123# repo:Git 仓库 directory:本地目录$ git clone &lt;repo&gt;$ git clone &lt;repo&gt; &lt;directory&gt; 8、与远程仓库同步12345678# 增加一个新的远程仓库，并命名$ git remote add [origin] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch]]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Github建立个人主页]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[前言在网上搜索一些技术问题时，经常会看到一些非常简约大气的个人博客站点，所以也非常希望自己也可以搭建一个类似的个人站点。后来得知可以借助于Hexo和Github方便的生成属于自己的个人主页。 Hexo是一个快速、简洁且高效的博客框架。Hexo 使用（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 同时Hexo也支持丰富的主题模板，在此基础上，经过简单几步指令的执行，就可以生成非常美观的个人站点。 Github提供静态网站托管服务 ，我们可以将Hexo生成的网页项目托管到Github上，这样就可以通过互联网随时随地访问我们的网站，并且 GitHub Pages 支持绑定个人域名，本文也会介绍如何在freenom上申请域名，然后绑定到GitHub Pages，这样就可以通过个人域名访问自己的网站了。 一、安装环境准备1、检测环境变量在安装Hexo之前，需要安装Git 和Node.js 。 Git是一个开源的分布式版本控制系统 ，通过它可以将我们的本地代码库方便推送到远程仓库Github。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 ，Node.js 的包管理器 npm，是全球最大的开源库生态系统，npm类似于python中的pip。稍后便可以使用npm来安装Hexo 。 如果电脑之前安装过Git和Node.js，那么可以检测下安装环境，看是否正确安装。 检测方法，win+R键，输入cmd，在控制台窗口依次输入以下3条指令检查版本，如果都可以正确返回，说明安装没有问题。 123git --versionnode -vnpm -v 由于我的电脑之前就安装过git，但是可能环境变量出了问题，导致后面无法部署，之后添加了git/cmd环境变量，hexo环境变量又出了问题，添加了hexo，node环境变量又出了问题，之后干脆全部卸载重装了，所以检测这一步非常必要。 2、安装Git进入Git官网，下载对应版本的安装包，如果是windows，直接默认下一步安装即可，详细的安装过程和安装选项参见这篇文章： Git中文详细安装教程 3、安装Node.jsNode.js的安装也十分简便，直接去官网下载安装包，默认下一步安装即可。 安装完成后，再进行上面的检测，如果出现命令不能识别的情况，可能需要手动添加环境变量，或者重新安装。 二、Git和Github配置1、注册github账号首先需要一个github账号，如果还没有注册，进入官网注册即可，由于服务器在国外，访问速度可能不是很快。 2、创建仓库Github pages服务默认的仓库名是&lt;你的github用户名&gt; + github.io 所以需要建立一个这样的代码库，以便于存储我们的网站代码。 建立过程如下： 进入自己的github主页，点击左边的New repository按钮 Repository name填写&lt;你的github用户名&gt; + github.io，比如我的账号是wychencr，那么仓库名一定要填写wychencr.github.io，这里不能填错了 Description 可以填写一段文字描述，随便都可以，仓库属性选择public Initialize this repository with a README 可以不勾选 最后点击Create repository按钮即可 3、Git设置用户名与邮箱在桌面或其他任意位置，右键，选择git bash here，然后执行以下两条指令，”Your Name”和”email@example.com“分别填写自己的用户名和邮箱，如果之前就安装过git并且设置了个人信息，就可以忽略这个步骤。 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 4、使用SSH连接Git与Github后面我们经常需要将本地代码通过git推送到github上，为了避免每次都输入密码，所以使用SSH连接。 SSH( Secure Shell )是一种安全协议，详细介绍参加这篇博文：详述SSH的原理及其应用 将Git与Github连接分为以下两步完成： 生成SSH公钥和秘钥在桌面或其他任意位置，右键，选择git bash here，然后执行以指令 1$ ssh-keygen -t rsa 表示使用RSA算法生成key，指令执行期间一直回车就可以了，最后会在用户文件夹下生成两个文件“id_rsa”和“id_rsa.pub” ，如图所示： “id_rsa.pub”对应的就是公钥，在C盘找到它，用记事本打开这个文件，复制其内容。 添加SSH公钥到github登录github账号，点击右上角的头像，选择Setting，在左侧Personal settings菜单栏选择SSH and GPG keys ，然后点击右上角的New SSH Key，将“id_rsa.pub”的内容复制到输入框中，标题title可以不填，注意SSH key 代码的前后不要留多余的空格或者回车。 添加完成后如下图所示： 这样，在传输时，远程的公钥就可以与本地的秘钥进行匹配了。 验证是否连接成功在 git bash 中输入以下指令： 1$ ssh -T git@github.com 看到以上结果说明SSH匹配成功。 三、安装Hexo1、使用npm安装Hexo进入cmd界面，输入以下指令即可安装好Hexo： 1$ npm install -g hexo-cli 如下图所示，可能等待时间稍长，我这里花了将近3分钟。 2、建立网站首先在本地电脑建立一个文件夹，用于管理和存储网站的代码，文件夹路径尽量不要有中文或者空格，避免出现意外的问题，比如我在E盘根目录建立一个HexoBlog文件夹。 然后执行下列三条指令即可建立好最基本的网站，非常便捷。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install &lt;folder&gt;是刚刚在本地建立的文件夹名称，比如我建立的文件夹是HexoBlog，所以我执行的指令就是 123$ hexo init HexoBlog$ cd HexoBlog$ npm install 过程如下图所示： 此时打开E:\HexoBlog\HexoBlog目录，可以看到生成的文件目录结构为： 12345_config.yml: 网站的配置信息，您可以在此配置大部分的参数package.json: 应用程序的信息scaffolds: 模版文件夹。当新建文章时，Hexo会根据scaffold来建立文件source: 存放用户资源的地方,比如用户新建的博客文章themes： 主题文件夹，Hexo会根据主题来生成静态页面 3、启动本地服务器 执行以下指令，启动本地服务器 1$ hexo server 浏览器中访问 http://localhost:4000/ 即可浏览到Hexo生成的最基本的网站 如果出现 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000 浏览器访问地址改成http://localhost:5000 四、新建和部署文章1、新建一篇文章1$ hexo new &lt;title&gt; &lt;title&gt;是文章标题，执行上述指令后，在/sources/_post文件夹下就会产生一个名为“title”的md文件，编辑它即可。 2、生成静态文件12$ hexo generate$ hexo g # 简写 当代码仓库中有文件改变时，执行上述指令可以重新生成静态文件，使改动生效。 3、本地查看效果在改动项目之后，可以先启动本地服务，在4000端口查看是否是自己预期的结果，如果没有问题，在部署到远程仓库。 12$ hexo server$ hexo s # 简写 4、部署到github此步骤可以将本地生成的项目文件推送部署到远程仓库，这样就可以使用username.github.io这样链接来访问我们的网站了。 12$ hexo deploy$ hexo d # 简写 如果是第一次部署，需要修改配置文件/HexoBlog/_config.yml： 1234deploy: type: git repo: &lt;repository url&gt; branch: [branch] [repository url]：填写之前新建的那个仓库地址，填写SSH地址，形式是 git@github.com:/.github.io.git [branch]：默认master 然后执行以下指令： 12$ npm install hexo-deployer-git --save$ hexo d 执行成功后，在github上的仓库中可以看到被部署的文件，稍微等待一段时间，就可以通过username.github.io访问到页面了。 五、更改Hexo主题1、下载主题在Hexo的主题商店 可以看到各种主题，选择自己喜欢的主题，下载压缩包，解压，放到/theme文件夹下。 以Next主题为例，首先访问Next的github仓库，下载解压，重命名为“next”，放入/theme文件夹下。 2、修改项目配置文件项目配置文件位于/HexoBlog/_config.yml，修改theme项为next： 1theme: next 注意冒号和next之间有一个空格。 3、修改主题配置文件主题配置文件位于/HexoBlog/themes/next/_config.yml。 Next主题支持四种样式效果，预览效果见官方说明文档 1234Muse 方案: LEAFERx | XiaMo | OAwansix_pointed_star Mist 方案: Jeff | uchuhimo | xirongpisces Pisces 方案: Vi | Acris | Rainygemini Gemini 方案: Ivan.Nginx | Raincal | Dandy 修改Schemes 1234scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 默认是第一种，如果想改成其他效果，只要把对应项的注释取消，再把第一项注释掉即可。 修改语言 12/HexoBlog/_config.yml# language: zh-Hans 添加评论系统 进入来必力官网，使用谷歌邮箱注册登录，获取uid，然后复制到主题配置文件的livere_uid处： 添加一个标签/分类页面/社交媒体/Feed link 见官方说明文档 更多配置技巧见知乎专栏：Hexo搭建的GitHub博客之优化大全 六、一些注意事项1、博客文章中带图片的情况网上比较普遍的方案是安装一个图片上传插件，然后改成配置文件，再在资源文件夹下建立一个img文件夹，然后将图片都放到img文件夹中，然后在博文中使用相对路径。 这样做有两个问题： 一是操作相对繁琐，而是增加了仓库所占的容量，在推送到远程仓库时也会更加缓慢； 二是github pages对仓库容量有限制，不超过300M 因此推荐使用微博图床，可以在Chrome商店中搜索“微博图床”扩展，下载，之后登陆微博中账号就可以使用了。 2、Markdown写作工具推荐Typora，下载地址https://www.typora.io/ Typora是一款好用极简免费的跨平台Markdown编辑器，软件使用这款软件能够帮助用户轻松将文本转换到HTML，软件从底层向上设计，软件支持markdown的标准语法，同时这款软件还支持动态预览功能，一键预览，让一切都变得如此干净、纯粹，是一款不可多得的优质markdown编辑器。 3、Next主题自动生成目录 如果不想目录自动编号，修改主题设置文件，将number:改为false： 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 自动生成目录混乱问题 父标题与子标题之间不能跨等级 123456H2 H4 H4H2 H4 ... 这样的结构可能就会出现问题，修改为连续的等级即可。 4、标注文章的分类和标签1234567title: xxxdate: 2018-10-18 15:14:41tags:- tag_A- tag_Bcategories:- categorie_C 5、CNAME文件被覆盖的问题当将github pages的url与自己的域名绑定后，在仓库中会生成一个CNAME文件，记录了域名。但是每次从本地部署代码后，github仓库中的CNAME文件就会被删除。 解决这个问题，可以把CNAME文件下载下来，放到仓库的/source文件夹中，再部署，就不会被覆盖了。 6、Hexo源文件的备份我们上传到github上的实际上是本地源代码库生成的静态文件，位于/public文件路径下。而我们的配置文件和博客.md文件等实际上都没有上传，如果硬盘除了问题，可能就没办法恢复了，所以需要备份本地源代码库，可以将其上传到github中，这样当我们更换电脑环境时，也可以重新从github上把源代码clong下来。 一种比较推荐的方法是，在github仓库中新建一个分支，保存源代码，另一个保存静态文件。 每次更改本地文件时，分别对两个分支执行deployed和push命令，这样就可以在生成静态文件的同时，也备份了源代码。 详细操作参见这篇博文： Hexo博客备份 当然，也可以新建一个github远程仓库，在本地将源代码仓库复制一份到硬盘的其他分区，备份到对应的远程仓库上，然后每次更新博文时，复制一份md文件到这个本地备份文件夹，再执行push操作，将md文件备份到远程仓库上。 当更换环境时，将备份仓库clone下来，安装Hexo环境，再重新生成部署即可。 这样做的好处是避免了分支操作，防止弄混淆，代价是多了一次复制操作，但是同时也算是给本地备份增加了一份保障。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法学习总结]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[动态规划与贪心、分治的区别 贪心算法(Greed alalgorithm) 是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致全局结果是最好或最优的算法。 分治算法(Divide and conquer alalgorithm) 字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 动态规划算法(Dynamic programming，DP) 通过将原问题分解为相对简单的子问题的方式来求解复杂问题。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 贪心法在处理每个子问题时，不能回退，而动态规划可以保存之前的结果，择优选择。下面针对Interval Scheduling 问题，分析动态规划在实际问题中的应用。 Interval Scheduling 问题 如下图所示，每个长条方块代表一个工作，总有若干个工作a、b… h，横坐标是时间，方块的起点和终点分别代表这个工作的起始时间和结束时间。 当两个工作的工作时间没有交叉，即两个方块不重叠时，表示这两个工作是兼容的(compatible)。 当给每个工作赋权值都为1时，则称为 Unweighted Interval Scheduling 问题；当给每个工作赋不同的正权值时，则称为 Weighted Interval Scheduling 问题。 问题最终是要找到一个工作子集，集合内所有工作权值之和最大且集合内每个工作都兼容。 对于 Unweighted Interval Scheduling 问题，使用贪心算法即可求解，具体做法是按照结束时间对所有工作进行排序，然后从结束最晚的工作开始，依次排除掉与前一个不兼容的工作，剩下的工作所组成的集合即为所求。 然而，对于 Weighted Interval Scheduling 问题，贪心法找到的解可能不是最优的了。此时考虑使用动态规划算法解决问题，兼顾权值选择和兼容关系。 定义P(j)1、首先依然按照结束时间对所有的工作进行排序； 2、定义p(j)为在工作j之前，且与j兼容的工作的最大标号，通过分析每个工作的起始时间和结束时间，可以很容易计算出p(j); 3、例如下图所示，p(8)=5，因为工作7和6都与8不兼容，工作1到5都与8兼容，而5是其中索引最大的一个，所以p(8)=5。同理，p(7)=3,p(2)=0。 分析递归关系1、定义opt(j)是j个工作中，所能选择到的最佳方案，即opt(j)是最大的权值和； 2、对于第j个工作，有两种情况： case 1: 工作j包含在最优解当中，那么往前递推一步，j之前能选择到的最优解是opt(p(j))，即 case 2: 工作j不在最优解中，那么从j个工作中选取解集和从j-1个工作中选取解集是一样的，即 3、当j=0时，显示结果为0，这是边界条件。 后一步的结果取前一步所有可能情况的最大值，因此综上所述，能得到动态规划的递归关系为： 代码实现1、递归法 递归会使得空间复杂度变高，一般不建议使用。 2、自底向上法 从小到大进行计算，这样每次都可以利用前一步计算好的值来计算后一步的值，算法时间复杂度为O(nlogn)，其中排序花费O(nlogn)，后面的循环花费O(n)。 Knapsack Problem 问题背包问题的定义 如下图所示，给定一个背包Knapsack，有若干物品Item 每个item有自己的重量weight，对应一个价值value 背包的总重量限定为W 目标是填充背包，在不超重的情况下，使背包内物品总重量最大。 对于下图的例子，一种常见的贪心思想是：在背包可以装得下的情况下，尽可能选择价值更高的物品。那么当背包容量是W=11时，先选择item5，再选择item2，最后只能放下item1，总价值为28+6+1=35。实际上最优解是选择item3和item4，价值18+22=40。这说明了贪心算法对于背包问题的求解可能不是zuiyou的。下面考虑使用动态规划算法求解，首先要推导递归关系式。 推导递归关系式类似于Weighted Interval Scheduling问题，定义opt(i, w)表示在有i个item，且背包剩余容量为w时所能得到的最大价值和。 考虑第i个item，有选和不选两种情况： case 1: 如果选择第i个item，则 case 2: 如果不选择第i个item，则 边界条件: 当i=0时，显然opt(i,w)=0。 后一步的结果取前一步所有可能情况的最大值，因此综上所述，能得到动态规划的递归关系为： 自底向上求解 算法迭代过程如下表： 算法运行时间分析 值得注意的是，该算法相对于输入尺寸来说，不是一个多项式算法，虽然O(nW)看起来很像一个多项式解，背包问题实际上是一个NP完全问题。 为了便于理解，可以写成这种形式： W在计算机中只是一个数字，以长度logW的空间存储，非常小。但是在实际运算中，随着W的改变，需要计算nW次，这是非常大的（相对于logW来说）。例如，当W为5kg的时候，以kg为基准单位，需要计算O(5n)次，当W为5t时，仍然以kg为单位，需要计算O(5000n)次，而在计算机中W的变化量相对很小。 Sequence AlignmentDefine edit distance给定两个序列x1,x2…xi和y1,y2,…,yj。要匹配这两个序列，使相似度足够大。首先需要定义一个表示代价的量-Edit distance，只有优化使这个量最小，就相当于最大化匹配了这两个序列。 Edit distance的定义如下所示。 其中，匹配到空，设距离为delta，否则字母p和q匹配的距离记为alpha(p,q)，如果p=q，则alpha=0； 那么两个序列匹配的总代价为： 建立递推关系设opt(i,j)是序列x1,x2…xi和y1,y2,…,yj之间匹配所花费的最小代价。当i，j不全为0时，则分别有三种情况，分别是xi-gap，yj-gap，xi-yj，分别计算不同匹配情况所花费的代价，再加上前一步的结果，就可以建立递推关系式，如下所示。 算法实现 算法复杂度时间和空间复杂度皆为O(mn)。 下面再分析一个具体的编程问题，使用动态规划算法，但是和上面的DP又有一些区别。 合唱团问题问题定义 有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？ 输入描述 每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;= n &lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;= ai &lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &lt;= k &lt;= 10, 1 &lt;= d &lt;= 50)。 输出描述 输出一行表示最大的乘积。 问题分析 此题的第一个关键点是“要求相邻两个学生的位置编号的差不超过 d”，如果按照传统的DP思路，定义opt(i,k)表示在前i个学生中选取k个学生的最大乘积，建立递推关系: 则无法实现“相邻两个学生的位置编号的差不超过 d”的要求。因此，需要定义一个辅助量，来包含对当前学生的定位信息。 定义f(i,k)表示在前i个学生中选取k个学生，且第i个学生必选时，所选学生的能力值乘积，这样就包含对当前学生的定位信息，f的递推关系可以表示为 其中，j是一个比i小的值，最大为i-1，i、j之差不超过D，f(j,k-1)表示在前j个学生中，选择k-1个学生，且第j个学生必选。f(i,k)选择了第i个学生，f(j,k-1)选择了第j个学生，i、j之差不超过D，这样就可以满足题目要求了。 辅助量f(i,k)并不是我们最终要得到的结果，最终结果opt(i,k)表示在前i个学生中选取k个学生的最大乘积，因此，可以得到opt(i,k)和f(i,k)的关系为： 该问题的第二个关键点是学生的能力值在-50到+50之间，每次选择的学生的能力值有正有负，所以需要两个f记录最大和最小值，定义fmax和fmin，在每次迭代f的过程中： 当k=K，i=N时，最终所求的: 边界条件k=1时，f(i,k=1)=v(i) 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*********************************************************************** Ran Chen &lt;wychencr@163.com&gt;** Dynamic programming algorithm**********************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N, D, K; // 总共N个学生 vector &lt;int&gt; value; while (cin &gt;&gt; N) &#123; for (int i = 0; i &lt; N; ++i) &#123; int v; cin &gt;&gt; v; value.push_back(v); &#125; break; &#125; cin &gt;&gt; K; // 选择K个学生 cin &gt;&gt; D; // 相邻被选择学生的序号差值 // fmax/fmin[i, k]表示在选择第i个数的情况下的最大/小乘积 vector &lt;vector &lt;long long&gt;&gt; fmax(N+1, vector &lt;long long&gt; (K+1)); vector &lt;vector &lt;long long&gt;&gt; fmin(N+1, vector &lt;long long&gt; (K+1)); // 边界条件k=1 for (int i = 1; i &lt;= N; ++i) &#123; fmax[i][1] = value[i - 1]; fmin[i][1] = value[i - 1]; &#125; // 自底向上dp, k&gt;=1 for (int k = 2; k &lt;= K; ++k) &#123; // i &gt;= k for (int i = k; i &lt;= N; ++i) &#123; // 0 &lt;= j &lt;= i-1 &amp;&amp; i - j &lt;= D &amp;&amp; j &gt;= k-1 long long *max_j = new long long; *max_j = LLONG_MIN; long long *min_j = new long long; *min_j = LLONG_MAX; // f(i, k) = max_j &#123;f(j, k-1) * value(i)&#125; int j = max(i - D, max(k - 1, 1)); for ( ; j &lt;= i - 1; ++j) &#123; *max_j = max(*max_j, max(fmax[j][k - 1] * value[i - 1], fmin[j][k - 1] * value[i - 1])); *min_j = min(*min_j, min(fmax[j][k - 1] * value[i - 1], fmin[j][k - 1] * value[i - 1])); &#125; fmax[i][k] = *max_j; fmin[i][k] = *min_j; delete max_j; delete min_j; &#125; &#125; // opt(N, K) = max_i &#123;f(i, K)&#125;, K &lt;= i &lt;= N long long *temp = new long long; *temp = fmax[K][K]; for (int i = K+1; i &lt;= N; ++i) &#123; *temp = max(*temp, fmax[i][K]); &#125; cout &lt;&lt; *temp; delete temp; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB安装libsvm工具箱的方法]]></title>
    <url>%2F2018%2F08%2F12%2FMATLAB%E5%AE%89%E8%A3%85libsvm%E5%B7%A5%E5%85%B7%E7%AE%B1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[支持向量机（support vector machine，SVM）是机器学习中一种流行的学习算法，在分类与回归分析中发挥着重要作用。基于SVM算法开发的工具箱有很多种，下面我们要安装的是十分受欢迎的libsvm工具箱。 libsvm简介 LIBSVM 是台湾大学林智仁(Lin Chih-Jen)副教授等开发设计的一个简单、易于使用和快速有效的 SVM 模式识别与回归的软件包，它不仅提供了编译好的可在 Windows 系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它操作系统上应用； 该软件还有一个特点，就是对 SVM 所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数就可以解决很多问题；并且提供了交互检验(Cross-SVM回归等问题，包括基于一对一算法的多类模式识别问题。 libsvm与MATLAB自带的svm工具箱的区别在MATLAB中，同样自带了一个svm工具箱，不过相比于libsvm，在功能性和易用性方面有一些差距。具体差别表现在： MATLAB自带的svm实现函数仅支持分类问题，不支持回归问题；而libsvm不仅支持分类问题，亦支持回归问题 MATLAB自带的svm实现函数仅支持二分类问题，多分类问题需按照多分类的相应算法编程实现；而libsvm采用一对一方法支持多分类 MATLAB自带的svm工具箱无法改变高斯核函数中的参数，而libsvm可以 MATLAB自带的svm工具箱也有一些优点，比如在解决二次规划问题时，可选三种方法（经典二次方法；SMO；最小二乘），而libsvm只能是SMO。 常见的扩展为多分类的方法有： 一对一（one-versus-one）方法，训练时对于任意两类样本都会训练一个二分类器，最终得到k(k-1)/2个二分类器，共同组成k分类器。对未知样本分类时，使用所有的k(k-1)/2个分类器进行分类，将出现最多的那个类别作为该样本最终的分类结果。 一对多（one-versus-rest）方法：训练时依次把k类样本中的某个类别归为一类，其它剩下的归为另一类，使用二分类的SVM训练处一个二分类器，最后把得到的k个二分类器组成k分类器。对未知样本分类时，分别用这k个二分类器进行分类，将分类结果中出现最多的那个类别作为最终的分类结果。 libsvm的下载在libsvm的官方主页上可以下载libsvm的扩展包，支持MATLAB、Java、Python等多种语言，这里我们选择MATLAB版本，下载zip文件即可。 或者直接下载我分享的文件包，点击这里下载 注意如果是从官方主页上下载，需要再下载一个数据集[heart_scale.mat]，方便之后的测试，点击这里下载。 如果是下载我分享的文件包，里面已经包含了这个数据集.mat文件，就不需要再下载了。 libsvm的安装在\libsvm-3.23\matlab目录下，有一个README文件，详细说明了安装方法。 如果是windows 64位系统，预编译的二进制文件已经提供，在\libsvm-3.23\windows文件下，可以看到4个文件，分别是libsvmread.mexw64、libsvmwrite.mexw64、svmtrain.mexw64、svmpredict.mexw64。 这样可以跳过下面第一步的编译步骤。 1.编译如果是win32位系统，需要自己重新编译c文件，生成MATLAB可识别的mexw32文件。编译方法在上述的README文件也有说明。 将MATLAB的工作文件夹调整到\libsvm-3.23\matlab目录下，在MATLAB的命令行窗口输入&gt;&gt; mex -setup，然后选择编译器如VS2010，最后输入指令&gt;&gt;make。编译完成后，当前路径下会生成对应的mexw32（32位系统）mexw64（64位系统）文件。 过程如下： 123456789101112131415161718192021matlab&gt;&gt; mex -setupWould you like mex to locate installed compilers [y]/n? ySelect a compiler:[1] Microsoft Visual C/C++ version 7.1 in C:\Program Files\Microsoft Visual Studio[0] NoneCompiler: 1Please verify your choices:Compiler: Microsoft Visual C/C++ 7.1Location: C:\Program Files\Microsoft Visual StudioAre these correct?([y]/n): ymatlab&gt;&gt; make 注意： 我的操作系统是win7 64位，原先安装的是MATLAB2014a和VS2015，发现并不支持libsvm工具包中提供好的mexw64文件，原因是MATLAB的版本过低。 随后我考虑重新编译生成适合自己版本的mexw64文件，结果发现MATLAB2014a不支持识别VS2015,最高支持到VS2013。 所以解决方法有两种，一种是给给VS降级，一种是给MATLAB升级。由于前者涉及很多.net和c++库文件，比较繁琐，所以最方便的做法是安装新版本的MATLAB，新老版本的MATLAB只要不安装在一个文件夹下，一般不会出现干扰情况。 安装MATLAB2016及以上版本就可以支持以上的mexw64文件，同时也能识别更新的c/c++编译器。 MATLAB 2016b的下载、安装、激活方法，可以参考这个链接。 2.重命名函数在得到libsvmread.mexw64、libsvmwrite.mexw64、svmtrain.mexw64、svmpredict.mexw64这4个文件后，为了避免和svm内置的函数冲突，最好将svmtrain.mexw64、svmpredict.mexw64这两个文件重命名为libsvmtrain.mexw64、libsvmpredict.mexw64。 3.添加到toolbox将libsvm-3.23文件夹放置到\MATLAB R2016b\toolbox目录下； 主页&gt; 设置路径&gt; 添加文件夹&gt; 选择libsvm-3.23文件夹； 添加并包含子文件夹&gt; 选择libsvm-3.23文件夹； 主页&gt; 预设&gt; 常规&gt; 更新工具箱缓存&gt; 确定 测试在MATLAB命令行窗口输入一下指令： 123load heart_scalemodel = libsvmtrain(heart_scale_label, heart_scale_inst, &apos;-c 1 -g 0.07&apos;);[predict_label, accuracy, dec_values] = libsvmpredict(heart_scale_label, heart_scale_inst, model); 若出现以下结果，说明安装正确。 更详细的关于libsvm的使用方法可以参考libsvm文件夹下的README文件或者是官方主页的说明。 References 支持向量机 - 维基百科，自由的百科全书 MATLAB自带的svm实现函数与libsvm差别 - CSDN博客 LibSVM 在 Matlab中的使用 - 星天炎地 | Dytan Blog Matlab + LibSVM + 问题集锦【20170407】 - CSDN博客 libsvm使用说明-码农场 MatLab2016b破解版安装教程 - CSDN博客 LIBSVM – A Library for Support Vector Machines]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>SVM</tag>
        <tag>Libsvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法 DFS深度优先搜索 （递归与非递归实现）]]></title>
    <url>%2F2018%2F08%2F07%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[回溯法是一种选优搜索法（试探法），被称为通用的解题方法，这种方法适用于解一些组合数相当大的问题。通过剪枝（约束+限界）可以大幅减少解决问题的计算量（搜索量）。 基本思想将n元问题P的状态空间E表示成一棵高为n的带权有序树T，把在E中求问题P的解转化为在T中搜索问题P的解。 深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。 –from wiki 实现方法1、按选优条件对T进行深度优先搜索，以达到目标。 2、从根结点出发深度优先搜索解空间树 3、当探索到某一结点时，要先判断该结点是否包含问题的解 如果包含，就从该结点出发继续按深度优先策略搜索 否则逐层向其祖先结点回溯（退回一步重新选择） 满足回溯条件的某个状态的点称为“回溯点” 4、算法结束条件 求所有解：回溯到根，且根的所有子树均已搜索完成 求任一解：只要搜索到问题的一个解就可以结束 遍历过程 典型的解空间树第一类解空间树：子集树当问题是：从n个元素的集合S中找出满足某种性质的子集时相应的解空间树称为子集树，例如n个物品的0/1背包问题。 这类子集树通常有2^n个叶结点 解空间树的结点总数为2^(n+1) - 1 遍历子集树的算法需Ω(2^n)计算时间 第二类解空间树：排列树当问题是：确定n个元素满足某种性质的排列时相应的解空间树称为排列树，例如旅行商问题。 DFS搜索在程序中可以两种方式来实现，分别是非递归方式和递归方式。前者思路更加清晰，便于理解，后者代码更加简洁高效。 非递归实现非递归实现需要借助堆栈(先入后出，后入先出)，在C++中使用stack容器即可。 问题若给定一个序列，需要找到其中的一个子序列，判断是否满足一定的条件。下面将程序实现DFS对子序列的搜索过程。 实现步骤：1、首先将根节点放入堆栈中。 2、从堆栈中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜寻并回传结果。 否则将它某一个尚未检验过的直接子节点加入堆栈中。 3、重复步骤2。 4、如果不存在未检测过的直接子节点。 将上一级节点加入堆栈中。 重复步骤2。 5、重复步骤4。 6、若堆栈为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 C++代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*********************************************************************** Ran Chen &lt;wychencr@163.com&gt;** Back-track algorithm （by DFS）**********************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;class Node&#123;public: int num; // 节点中元素个数 int sum; // 节点中元素和 int rank; // 搜索树的层级 int flag; // 0表示子节点都没访问过，1表示访问过左节点，2表示访问过左右节点 vector &lt;int&gt; path; // 节点元素 Node(); Node(const Node &amp; nd);&#125;;// 默认构造函数Node::Node()&#123; num = 0; sum = 0; rank = 0; flag = 0; // path is empty&#125;// 复制构造函数Node::Node(const Node &amp; nd)&#123; num = nd.num; sum = nd.sum; rank = nd.rank; flag = nd.flag; path = nd.path;&#125;// -----------------------------------------------------------------void DFS(const vector &lt;int&gt; &amp; deque)&#123; stack &lt;Node *&gt; stk; // 存储节点对应的指针 stack &lt;Node *&gt; pre_stk; // 存储上一级节点（回溯队列） Node * now = new Node; // 指向当前节点 Node * next = NULL; // 指向下一个节点 Node * previous = NULL; // 指向上一个节点 while (now) &#123; if (now-&gt;rank &lt; deque.size() &amp;&amp; (now-&gt;flag == 0)) &#123; // 左叶子节点,选择当前rank的数字 next = new Node(*now); next-&gt;num++; next-&gt;sum += deque[next-&gt;rank]; next-&gt;path.push_back(deque[next-&gt;rank]); next-&gt;rank++; next-&gt;flag = 0; stk.push(next); // 将左节点加入堆栈中 now-&gt;flag = 1; // 改变标志位 // 将当前节点作为上一级节点存储并删除 previous = new Node(*now); pre_stk.push(previous); delete (now); // 取出堆栈中的待选节点作为当前节点 now = stk.top(); stk.pop(); // 显示搜索路径 for (int i = 0; i &lt; next-&gt;path.size(); ++i) &#123; cout &lt;&lt; " " &lt;&lt; next-&gt;path[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; continue; // DFS每次仅选取一个子节点，再进入下一步循环 &#125; if (now-&gt;rank &lt; deque.size() &amp;&amp; (now-&gt;flag == 1)) &#123; // 右节点，不选择当前rank的数字 next = new Node(*now); next-&gt;rank++; next-&gt;flag = 0; stk.push(next); now-&gt;flag = 2; // 将当前节点作为上一级节点存储并删除 previous = new Node(*now); pre_stk.push(previous); delete (now); // 取出堆栈中的待选节点作为当前节点 now = stk.top(); stk.pop(); continue; &#125; // 回溯结束 if (pre_stk.empty()) &#123; break; &#125; // 没有子节点或者没有未搜索过的子节点时，回退到上一级节点（回溯） if (now-&gt;rank &gt;= deque.size() || now-&gt;flag == 2) &#123; delete (now); now = pre_stk.top(); pre_stk.pop(); &#125; &#125;&#125;// -----------------------------------------------------------------int main()&#123; stack &lt;Node*&gt; stk; vector &lt;int&gt; deque &#123; 2,3,5,7 &#125;; DFS(deque); cin.get(); return 0;&#125; 运行结果 程序说明1、定义了一个Node节点类，表示当前状态下已经搜索到的序列，path记录了这个子序列的值，并且类中添加了num（子序列中元素数目）、sum（子序列元素和）等属性，通过这些属性可以判断是否找到满意解或者用于剪枝。 2、对于原始序列中某个位置的数，其子序列中可以包含这个数，也可以不包含这个数，所以每次有两种选择，即每个节点有两个子节点。 3、flag属性标识了当前节点的子节点遍历情况。若flag=0，表示子节点都没访问过，下一步优先访问左节点，所以将左节点加入堆栈中；flag=1，表示访问过左节点，下一步访问右节点；flag=2，表示访问过左右节点。 4、当没有子节点（now-&gt;rank &gt;= deque.size()）或者左右节点都访问过时（flag=2），回溯到上一级节点。 5、程序循环中，首先通过now当前节点，找到下一个子节点next，将其加入堆栈中，便于下一步循环。在now节点销毁前，将其存到previous，并加入pre_stk堆栈中。这样在下一轮循环中，previous相对于now就是上一级节点，如果now不能找到其子节点，就要返回上一级，这样previous就可以重新赋给now，达到返回上一级的目的。 6、整个程序的终止条件是pre_stk堆栈为空时截止，说明所有节点都已经遍历过，并且没有再可回溯的节点了。实际运用中，可以通过其他属性（搜索到可行解）来提前终止程序。 递归实现参考自Coding_Or_Dead的博客 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include &lt;iostream&gt;int n, k; __int64 sum = 0;int a[4] = &#123; 2, 3, 5, 7 &#125;, vis[4] = &#123;0, 0, 0, 0&#125;;void DFS(int i, int cnt, int sm)//i为数组元素下标,sm为cnt个数字的乘积&#123; if (cnt == k) // 解中已包含k个数字 &#123; sum = sum + sm; return; &#125; if (i &gt;= n) return; if (!vis[i]) &#123; // 对第i个数字进行访问 vis[i] = 1; //a[i]被选，优先选择第i个加入到解中，接下来搜索第i+1个数字 DFS(i + 1, cnt + 1, sm*a[i]); //a[i]不选，不选择第i个，相当于右节点，接下来搜素第i+1个数字 DFS(i + 1, cnt, sm); vis[i] = 0; // 回溯 &#125; return;&#125;int main(void)&#123; n = 4, k = 2; DFS(0, 0, 1); printf("%I64d\n", sum); std::system("pause"); return 0;&#125; 程序说明1、程序目的：给定n个正整数，求出这n个正整数中所有任选k个相乘后的和，这里的数组a[4]存储原序列，vis[4]作为访问标志，k取2，结果输出为101，对应的序列是{2, 3}{2, 5}{2, 7}{3, 5}{3, 7}{5, 7}。 2、对于元素a[i]，每次对应两个选择。若选择将a[i]加入到解中，则解中元素个数+1，乘积结果a[i]，所以下一步更新为`DFS(i + 1, cnt + 1, sma[i])。若不选择a[i]，则解中的元素个数和乘积不变，下一步更新为DFS(i + 1, cnt, sm)`。 3、回溯时要将标志位重置。 References 深度优先搜索 - 维基百科，自由的百科全书 DFS深度优先搜索(入门) - CSDN博客 广度优先搜索 BFS算法 - 东聃 - 博客园]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA连接数据库详细过程]]></title>
    <url>%2F2018%2F08%2F03%2FIntelliJ-IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言IntelliJ IDEA集成了众多插件，方便开发者使用，使用其自带的Database工具就可以很方便的配置、连接到数据库，本次操作以MySQL为例，其中testjdbc数据库已经提前建好，里面有两张表emp_table 和 t_user，相关信息如下图。 连接到MySQL数据库1、选择数据源在IDEA中新建一个Java工程后，最右侧侧边栏会有个 Database 标签，点击此标签，然后点击+按钮，选择Data Source，选择MySQL，如果是其他数据源，选择其他对应按钮即可。过程如下图所示。 2、下载驱动如下图是下载好MySQL驱动的情况。如果是第一次进入此界面并且没有驱动，IDEA会在Driver处提示没有下载对应数据库类型的驱动，直接点击，就会自动下载，稍作等待后，结果显示为MySQL，若点击此标签，可以对MySQL的驱动文件进行进一步配置。 3、配置账户、密码信息如上图所示，需要填写数据库账户信息，这里我的用户名User为root，由于是本地数据库，所以Host填写为localhost，端口Port为3306，Password填写用户名对应的密码即可，Database可以填写想连接的数据库名，也可以暂时不填，待连接上后再设置。填写以上所有信息后，点击Test Connection按钮，如果显示成功Successful，说明连接成功，点击OK按钮，配置完成。 4、查看、修改数据库 连接到数据库后，在Database标签下，可以查看数据库结果，如下图所示，可以看到testjdbc库下有两张表，分别是emp_table 和 t_user，并且能看到表的列信息。如下图所示。 点击表名或者列名，就可以查看表信息，也可以修改表信息，如下图所示。 使用JDBC操作数据库1、导入驱动包到工程 在Database标签下，右键刚刚建立的数据源名，选择属性Properties，进入之前配置数据源的界面，如下图所示。 点击Driver处MySQL，查看驱动信息，如下图所示。 查看驱动包在计算机中的位置，记下这个路径，方便后面导入这个jar包，如下图。 查看到MySQL驱动包的位置后，关闭窗口，在主界面点击File-&gt;Project Structure，进入工程设置界面。然后在左侧栏，点击Modules，再选择Dependencies，再点击右侧的+按钮，选择JARs or directories，找到上面MySQL驱动jar包的位置，选择这个jar文件。成功导入后，在Export栏下会有两项，分别是jdk和刚刚导入的jar包，如下图所示。 导入成功后，在工程目录External Libraries下面也会出现导入的驱动包名称，如下图所示。 2、使用jdbc操作数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.sql.*;public class ConnMySQL &#123; public static void main(String[] args) throws Exception &#123; Connection conn = null; try &#123; // 加载驱动类 Class.forName("com.mysql.jdbc.Driver"); long start =System.currentTimeMillis(); // 建立连接 conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc", "root", "【填写对应的密码】"); long end = System.currentTimeMillis(); System.out.println(conn); System.out.println("建立连接耗时： " + (end - start) + "ms 毫秒"); // 创建Statement对象 Statement stmt = conn.createStatement(); // 执行SQL语句 ResultSet rs = stmt.executeQuery("select * from t_user"); System.out.println("id\tusername\tpwd\t\tregTime"); while (rs.next()) &#123; System.out.println(rs.getInt(1) + "\t" + rs.getString(2) + "\t\t" + rs.getString(3) + "\t\t" + rs.getString(4)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3、程序执行结果 上面的程序中，使用了一条查询语句，查询表t_user的内容，执行程序后的结果如下图。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广度优先搜索 BFS算法]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[BFS算法的概念广度优先搜索算法（Breadth-First-Search，BFS），又称作宽度优先搜索。BFS算法是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。 算法思想 1、首先将根节点放入队列中。 2、从队列中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜索并回传结果。 否则将它所有尚未检验过的直接子节点加入队列中。 3、若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。 4、重复步骤2。 搜索过程演示 说明 灰色的是加入队列中的活动节点，黑色是从活动节点队列中选取的扩展节点。 每次将一个活动节点标记为扩展节点后，进行判断，并将该点从活动节点队列中移除，再将该节点所有未检测的子节点加入活动节点队列中去。 接下来再从队列中选取新的活动节点作为扩展节点，如此循环下去，直至队列为空为止，说明已经遍历过所有的节点。 复杂度 因为所有节点都必须被存储，因此BFS的空间复杂度为 O(|V|+|E|)，其中 |V| 是节点的数目，而 |E| 是图中边的数目。 最差情形下，BFS必须查找所有到可能节点的所有路径，因此其时间复杂度为 O(|V|+|E|)。 C++实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Given a binary tree, find its minimum depth.//The minimum depth is the number of nodes along //the shortest path from the root node down to //the nearest leaf node.// 递归方法class Solution &#123;public: int run(TreeNode *root) &#123; if (!root) &#123; return 0; &#125; // 若左子树为空，返回右子树深度 + 1 if (root-&gt;left == nullptr) &#123; return (run(root-&gt;right) + 1); &#125; // 若右子树为空，返回左子树深度 + 1 if (root-&gt;right == nullptr) &#123; return (run(root-&gt;left) + 1); &#125; // 左右子树都不为空，返回较小值 int leftDepth = run(root-&gt;left); int rightDepth = run(root-&gt;right); return ((leftDepth &lt; rightDepth) ? (leftDepth + 1) : (rightDepth + 1)); &#125;&#125;;// BFS方法#include &lt;vector&gt;using namespace std;class Solution&#123;public: int run(TreeNode *root) &#123; if (!root) &#123; return 0; &#125; vector &lt;TreeNode *&gt; que; TreeNode *now = root; // 当前访问的节点 TreeNode *last = root; // 每层最后的一个节点 que.push_back(root); int depth = 1; // 初始深度 while (que.size()) &#123; // 取出队列中的第一个节点作为当前节点 now = que.front(); que.erase(que.begin()); // 如果当前节点没有子节点了，直接终止循环，说明是叶子节点，返回最小深度 if ((now-&gt;left == nullptr) &amp;&amp; (now-&gt;right == nullptr)) &#123; break; &#125; // 将子节点加入队列中 if (now-&gt;left != nullptr) &#123; que.push_back(now-&gt;left); &#125; if (now-&gt;right != nullptr) &#123; que.push_back(now-&gt;right); &#125; // 当访问到每层的最后一个节点时，深度+1 if (now == last) &#123; depth++; last = que.back(); // 将下一层最后一个节点赋给last &#125; &#125; return depth; &#125;&#125;; BFS代表性应用 MTK编程挑战赛决赛《算术迷宫》 References 深度优先搜索 - 维基百科，自由的百科全书 算法入门 广度/宽度优先搜索(BFS) - CSDN博客 Algorithms: Graph Search, DFS and BFS - YouTube]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[麻将胡牌算法及代码实现]]></title>
    <url>%2F2018%2F07%2F29%2F%E9%BA%BB%E5%B0%86%E8%83%A1%E7%89%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[麻将的玩法规则麻将的玩法规则众多，核心的玩法是一致的，本文将根据联发科2017年编程挑战赛的复赛题规则来实现。 牌的表示方式 ABCDEFGHI代表一到九萬，abcdefghi代表一到九条，123456789代表一到九饼 三种胡牌牌型 普通牌型，14张牌，形如：3+3+3+3+2。其中数字2代表两张相同的牌可成一组，形如XX。数字3代表三张相同或者连续的牌可成一组，形如XXX、XYZ。 龙七对，14张形如：2+2+2+2+2+2+2。 带杠，即普通牌型里三张一样的牌XXX可以升级成XXXX，称为一道杠。每多一道杠，牌总数可以增加一张。最多可以有4道杠，因此带杠的胡牌，牌总数最多可以达18张。 样例 ABCeee345456DD 胡牌，组牌方式为 ABC+eee+345+456+DD，普通牌型。 ABeeee345456DD 炸胡，因为AB两张牌未能形成组牌。 AAAABC123456333 炸胡，虽然看似组牌OK（AAA+ABC+124+345+456+333）但是不符合任何一种胡牌牌型。 AADDFF1133aagg 胡牌，暗七对。 AAAABBBBCCCCDDDD88 胡牌，3+3+3+3+2牌型，升级了4道杠。 AAA123789 炸胡，不符合任何一种牌型。 AAA111345666DEF88 炸胡，不符合任何一种牌型。 算法实现思路 1、普通牌型为3n+2的形式，和龙7对均为14张牌，若有杠则最多有18张牌，因此第一步可以判定，如果牌数小于14或者大于18，则必定不能胡牌； 2、对牌进行从小到大排序，方便后续判断。如果手牌数是14张，可以先判定是否是龙7对(对对胡)，其特点是每张奇数位的牌都和它后一位的牌相等。如果不是对对胡，则进入步骤3； 3、3n+2形式的普通牌型里面有一个对子，因此判断是不是胡牌牌型，可以先找出其中的一个对子。一张牌可能有2张也可能有4张，可以组成对子也可能组成暗杠或者杠，又或者是和后面的牌组成顺子。不管情况有多少种，对子一定是出现在重复的牌之中，只要每次遍历去除一个对子即可。接下来进入步骤4； 4、去除一个对子后，判定是否是3n牌型，即是否是全部由顺子或者暗杠组成。由于牌已经经过排序，所以只要观察第一张牌即可。 如果第一张牌的数量只有一张或者两张，则这张牌必须和后面的牌组成顺子，否则不能胡牌。如果存在这样的顺子，去除这个顺子 如果第一张牌的数量有三张或者四张，则可能组成一个暗杠，或者是和后面的牌组成顺子（先不考虑有杠的情况），去除这个暗杠（顺子） 一直循环以上的判断，满足条件则去掉这三张牌，直到牌数为0时，返回“胡牌”，否则回到步骤3中，将之前去除的对子放回，继续删除下一个对子。如果步骤3中尝试过所有的对子还没能满足胡牌条件时，则返回“不胡牌”； 5、如果牌数为15张，则至少包含一个4张牌的杠，否则不胡牌。如果包含多个杠，则依次遍历删除一个杠，再进入步骤3，判断是不是3n牌型。如果遍历完所有的杠后还不能胡牌，则返回“不胡牌”； 6、如果牌数是16张，则至少包含2个杠，依次遍历删一对杠的组合，余下同步骤5类似。同理，牌数为17张和18张时方法类似。 C++源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using std::vector;using std::cout;template &lt;typename T&gt;void showVector(vector &lt;T&gt; &amp; lst);vector &lt;int&gt; findReptPos(vector &lt;char&gt; &amp; lst);bool isDDH(const vector &lt;char&gt; &amp; lst);bool isHU3N(vector &lt;char&gt; &amp; lst);vector &lt;char&gt; delDUI(const vector &lt;char&gt; &amp; lst, const int x);bool is3N(vector &lt;char&gt; lst);int numOfFirst(vector &lt;char&gt; lst);bool checkGroup(vector &lt;char&gt; lst, const int num);void delGroup(vector &lt;char&gt; &amp; lst, const int num);vector &lt;char&gt; delGANG(const vector &lt;char&gt; &amp; lst, const int x);vector &lt;int&gt; findGangPos(const vector &lt;char&gt; &amp; lst);int main(int argc, char **argv)&#123; char *mahjong = argv[1]; vector &lt;char&gt; lst; for (int i = 0; mahjong[i] != '\0'; ++i) &#123; lst.push_back(mahjong[i]); &#125; std::sort(lst.begin(), lst.end()); // 从小到大排序 /*cout &lt;&lt; "sort: "; showVector(lst);*/ int num = lst.size(); // 麻将牌数量 if ((num &lt; 14) || (num &gt; 18)) &#123; cout &lt;&lt; "BAD"; return 0; &#125; if (num == 14) // 14张牌，2种胡牌法 &#123; if (isDDH(lst)) // 如果是对对胡 &#123; cout &lt;&lt; "GOOD"; return 0; &#125; if (isHU3N(lst)) &#123; cout &lt;&lt; "GOOD"; &#125; else &#123; cout &lt;&lt; "BAD"; &#125; return 0; &#125; if (num == 15) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() &lt; 1) &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 依次删除一个杠，再判断是否是3N牌型 for (int i = 0; i &lt; pos.size(); ++i) &#123; vector &lt;char&gt; newLst = delGANG(lst, pos[i]); /*cout &lt;&lt; "delGANG/"; showVector(newLst);*/ if (isHU3N(newLst)) &#123; cout &lt;&lt; "GOOD"; return 0; &#125; &#125; cout &lt;&lt; "BAD"; &#125; &#125; if (num == 16) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() &lt; 2) // 少于2个杠肯定不胡牌 &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 依次删除不同的2个杠组合,再判断是否是3N牌型 for (int i = 0; i &lt; pos.size() - 1; ++i) &#123; for (int j = i + 1; j &lt; pos.size(); ++j) &#123; // 注意先删除后一个杠，否则位置会变动 vector &lt;char&gt; newLst1 = delGANG(lst, pos[j]); vector &lt;char&gt; newLst2 = delGANG(newLst1, pos[i]); /*cout &lt;&lt; "delGANG/"; showVector(newLst2);*/ if (isHU3N(newLst2)) &#123; cout &lt;&lt; "GOOD"; return 0; &#125; &#125; &#125; cout &lt;&lt; "BAD"; &#125; &#125; if (num == 17) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() &lt; 3) // 少于3个杠肯定不胡牌 &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 依次删除不同的3个杠组合,再判断是否是3N牌型 for (int i = 0; i &lt; pos.size() - 2; ++i) &#123; for (int j = i + 1; j &lt; pos.size() - 1; ++j) &#123; for (int k = j + 1; k &lt; pos.size(); ++k) &#123; // 注意先删除后一个杠，否则位置会变动 vector &lt;char&gt; newLst1 = delGANG(lst, pos[k]); vector &lt;char&gt; newLst2 = delGANG(newLst1, pos[j]); vector &lt;char&gt; newLst3 = delGANG(newLst2, pos[i]); /*cout &lt;&lt; "delGANG/"; showVector(newLst3);*/ if (isHU3N(newLst3)) &#123; cout &lt;&lt; "GOOD"; return 0; &#125; &#125; &#125; &#125; cout &lt;&lt; "BAD"; &#125; &#125; if (num == 18) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() != 4) // 不是4个杠肯定不胡牌 &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 直接删除4个杠 vector &lt;char&gt; newLst1 = delGANG(lst, pos[3]); vector &lt;char&gt; newLst2 = delGANG(newLst1, pos[2]); vector &lt;char&gt; newLst3 = delGANG(newLst2, pos[1]); vector &lt;char&gt; newLst4 = delGANG(newLst3, pos[0]); /*cout &lt;&lt; "delGANG/"; showVector(newLst4);*/ if (newLst4[0] == newLst4[1]) &#123; cout &lt;&lt; "GOOD"; &#125; else &#123; cout &lt;&lt; "BAD"; &#125; &#125; &#125; return 0;&#125;// 显示列表内容template &lt;typename T&gt;void showVector(vector &lt;T&gt; &amp; lst)&#123; vector &lt;T&gt;::iterator iter; // 迭代器 for (iter = lst.begin(); iter != lst.end(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "\n";&#125;// 查找重复牌的位置vector &lt;int&gt; findReptPos(vector &lt;char&gt; &amp; lst)&#123; vector &lt;int&gt; pos; // 储存重复牌的位置 int temp_pos = 0; if (lst.size() &lt;= 1) // 牌数小于等于1，直接返回 &#123; return pos; &#125; // lst.size() &gt;= 2 vector &lt;char&gt;::iterator iter2; iter2 = lst.begin(); ++iter2; // 迭代器不支持算数运算,只能++/--/advance链式操作 if (lst.front() == *iter2) &#123; pos.push_back(temp_pos); &#125; vector &lt;char&gt;::iterator it_front; vector &lt;char&gt;::iterator it_back; for (auto iter1 = iter2; iter1 != (--lst.end()); iter1++) // 从第二位到倒数第二位 &#123; ++temp_pos; // 位置更新 it_front = iter1; --it_front; it_back = iter1; ++it_back; // 不等于前面的且等于后面的 if ((*iter1 != *it_front) &amp;&amp; (*iter1 == *it_back)) &#123; pos.push_back(temp_pos); &#125; &#125; return pos;&#125;// 是否是对对胡bool isDDH(const vector &lt;char&gt; &amp; lst)&#123; vector &lt;char&gt; newLst = lst; for (int i = 0; i &lt;= 12; ++i) &#123; if (newLst[i] != newLst[i + 1]) &#123; return false; &#125; ++i; &#125; return true;&#125;// 是否是普通牌型3nbool isHU3N(vector &lt;char&gt; &amp; lst)&#123; vector &lt;int&gt; pos = findReptPos(lst); // 找重复牌的位置 for (int i = 0; i &lt; pos.size(); ++i) // 依次去掉重复的对子 &#123; vector &lt;char&gt; newLst = delDUI(lst, pos[i]); // 删除一对牌 /*cout &lt;&lt; "delDUI/"; showVector(newLst);*/ if (is3N(newLst)) &#123; return true; &#125; &#125; return false;&#125;// 是否是N个顺子或者暗杠bool is3N(vector &lt;char&gt; lst)&#123; if (lst.size() % 3 != 0) &#123; return false; &#125; while (lst.size() &gt; 0) &#123; if (lst.size() &gt;= 3) &#123; int num = numOfFirst(lst); // 计算第一张牌的重复数量 if (checkGroup(lst, num)) // 检查是否有第一个顺子或者暗杠 &#123; delGroup(lst, num); // 删除这组顺子或者暗杠 &#125; else &#123; return false; &#125; &#125; /*cout &lt;&lt; "//"; showVector(lst);*/ &#125; return true;&#125;// 检查是否有第一个顺子或者暗杠bool checkGroup(vector &lt;char&gt; lst, const int num)&#123; if ((num == 1) &amp;&amp; (lst[1] == lst[0] + 1)) &#123; // 第二个数可能有重复情况 for (int i = 2; i &lt; lst.size(); ++i) &#123; if (lst[i] != lst[1]) &#123; if (lst[i] == lst[0] + 2) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; if ((num == 2) &amp;&amp; (lst[2] == lst[1] + 1)) &#123; // 第三个数可能有重复情况 for (int i = 3; i &lt; lst.size(); ++i) &#123; if (lst[i] != lst[2]) &#123; if (lst[i] == lst[1] + 2) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; if (num &gt;= 3) &#123; return true; &#125; return false;&#125;// 删除这组顺子或者暗杠void delGroup(vector &lt;char&gt; &amp; lst, const int num)&#123; if (num == 1) &#123; vector &lt;char&gt;::iterator iter = ++lst.begin(); for (int i = 2; i &lt; lst.size(); ++i) &#123; ++iter; if (lst[i] == (1 + lst[1])) &#123; lst.erase(iter); lst.erase(lst.begin()); lst.erase(lst.begin()); break; &#125; &#125; &#125; if (num == 2) &#123; vector &lt;char&gt;::iterator iter = ++(++lst.begin()); for (int i = 3; i &lt; lst.size(); ++i) &#123; ++iter; if (lst[i] == (1 + lst[2])) &#123; lst.erase(iter); lst.erase(++lst.begin()); // 删除第二位的牌 lst.erase(++lst.begin()); break; &#125; &#125; &#125; if (num &gt;= 3) &#123; lst.erase(lst.begin()); lst.erase(lst.begin()); lst.erase(lst.begin()); &#125;&#125;// 计算第一张牌的重复数量int numOfFirst(vector &lt;char&gt; lst)&#123; if (lst[0] != lst[1]) &#123; return 1; &#125; if ((lst[0] == lst[1]) &amp;&amp; (lst[1] != lst[2])) &#123; return 2; &#125; if (lst[0] == lst[2]) &#123; if (lst.size() == 3) &#123; return 3; &#125; if ((lst.size() &gt;= 4) &amp;&amp; (lst[2] != lst[3])) // lst[3]一定保证size&gt;=4 &#123; return 3; &#125; &#125; if ((lst[0] == lst[3]) &amp;&amp; (lst.size() &gt;= 4)) &#123; return 4; &#125; return 0;&#125;// 删除x和x+1位置的一对牌vector &lt;char&gt; delDUI(const vector &lt;char&gt; &amp; lst, const int x)&#123; vector &lt;char&gt; newLst; for (int i = 0; i &lt; lst.size(); ++i) &#123; if ((i != x) &amp;&amp; (i != (x + 1))) &#123; newLst.push_back(lst[i]); &#125; &#125; return newLst;&#125;// 删除起始位置为x的杠（4张牌）vector &lt;char&gt; delGANG(const vector &lt;char&gt; &amp; lst, const int x)&#123; vector &lt;char&gt; newLst; for (int i = 0; i &lt; lst.size(); ++i) &#123; if ((i &lt; x) || (i &gt; x + 3)) &#123; newLst.push_back(lst[i]); &#125; &#125; return newLst;&#125;// 查找杠的位置vector &lt;int&gt; findGangPos(const vector &lt;char&gt; &amp; lst)&#123; vector &lt;int&gt; pos; int temp_pos = 0; if (lst.size() &lt; 4) &#123; return pos; &#125; for (int i = 0; i &lt; lst.size() - 3; ++i) &#123; if (lst[i] == lst[i + 3]) &#123; pos.push_back(temp_pos); &#125; ++temp_pos; // 位置更新 &#125; return pos;&#125; 程序运行结果 程序从命令行参数取得输入数据，数据为一个字符串，代表一副牌。若这副牌达到胡牌条件，输出GOOD，否则输出BAD。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB常用指令记录]]></title>
    <url>%2F2018%2F06%2F27%2FMATLAB%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[123456789help + &apos;command name&apos; % 查询指令用法 Ctrl + Break % 强制终止程序运行Shift + Enter % command window下换行不运行指令M&apos;; % 复数的共轭，矩阵的转置inv() % 矩阵的逆det() % 矩阵的行列式值rank() % 求出矩阵的秩n = norm(X,p) % 求矩阵的p范数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990clear all；clc； % 清除工作空间，清空command window记录set(0,'defaultfigurecolor','w'); % 设置figure背景为白色X = zeros(n) % Create a n-by-n array of 0X = zeros(sz1,...,szN) % Create a sz1-...-szN array of 0X = ones(sz1,...,szN); % Create a sz1-...-szN array of 1I = eye(n); % Create a n-by-n identity identity matrixr = rand(sz1,...,szN); % 产生一个均匀分布的伪随机数矩阵r = randn(sz1,...,szN); % 产生一个标准正态分布的伪随机数矩阵r = randi([imin,imax], sz1,...,szN); % 产生一个区间内均匀分布的伪随机整数矩阵y = awgn(x,snr) % 给信号x添加add一个snr（dB）的高斯白噪声y = wgn(m,n,p) % 产生一个p（dBm）的高斯白噪声R = normrnd(mu,sigma,m,n,...) %产生均值mu 标准差sigma的正态分布矩阵seq = normrnd(mean, sigma, sz1, sz2) % 产生指定均值方差的正态分布的序列seq = randperm(n) % 产生乱序序列B = reshape(A,[m n])； % returns the m-by-n matrix B according Alength() % 返回矩阵最长维的的长度size() % 返回每一维的长度blkdiag(A, B) % 以A，和B为块创建块对角矩阵A(index, :, :) = [ ] % 空赋值，等效于删掉某行某列abs(); % 取绝对值/模angle(); % 取角度log2(n); % log以2为底取对数exp(); % 指数sqrt(); % 开方sind(theta); % theta为角度sin(theta); % theta为弧度% 计时器，结束时显示过程时间tic...toc% 进度条hWait = waitbar(0,'Please wait...');steps = 1000;for step = 1:steps % computations take place here waitbar(step / steps);endclose(hWait); load/save('filename，'variable') % 载入/存储变量值到mat文件find(X) % 查找某个值 返回索引data == X % 返回对应长度的布尔型矩阵disp('数据');disp(data); % 显示字符或变量值figure; % 创建新的figureset(0,'DefaultFigureProperty',PropertyValue...); % 设置figure默认参数属性plot(X,Y); % 绘制曲线图=============================================================== 颜色 线型--------------------------------------------------------------- y 黄色 . 圆点线 v 向下箭头 g 绿色 -. 组合 &gt; 向右箭头 b 蓝色 + 点为加号形 &lt; 向左箭头 m 红紫色 o 空心圆形 p 五角星形 c 蓝紫色 * 星号 h 六角星形 w 白色 . 实心小点 - 实线 r 红色 x 叉号形状 ^ 向上箭头 k 黑色 s 方形 d 菱形 -- 虚线 ===============================================================subplot(m,n,p); % 平铺figure为m行n列，指定当前figure为第p个polar(theta,rho) % 绘制极坐标图，theta,rho分别是向量contour(X, Y, Z) % 绘制等高线图mesh(X, Y, Z) % 绘制三维图scatter(X,Y) % 绘制散点图bar(X, Y, width, color) % 绘制柱状图（竖直）% 居中添加文本字符串text(pos_x, pos_y, num2str(data), 'VerticalAlignment', 'middle', 'HorizontalAlignment', 'center')set(gca, 'Fontname', '微软雅黑');xlabel('---', 'Fontname', '微软雅黑'); % 设置x轴标号样式set(gca,'xticklabel', &#123;'str1','str2','str2',...) % 设置x轴横轴标号title('---', 'Fontname', '微软雅黑'); % 设置标题样式axis([xMin xMax yMin yMax]); % 控制坐标显示范围axis tight; % 控制显示范围在数据区域grid on; % 开启网格]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法求图的直径并记录路径]]></title>
    <url>%2F2018%2F06%2F24%2FFloyd%E7%AE%97%E6%B3%95%E6%B1%82%E5%9B%BE%E7%9A%84%E7%9B%B4%E5%BE%84%E5%B9%B6%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[相关概念 对于一个图G=(V, E)，求图中两点u， v间最短路径长度，称为图的最短路径问题。最短路径中最长的称为图的直径。 其中，求图中确定的某两点的最短路径算法，称为单源最短路径算法。求图中任意两点间的最短路径算法，称为多源最短路径算法。 常用的路径算法有 Dijkstra算法 SPFA算法\Bellman-Ford算法 Floyd算法\Floyd-Warshall算法 Johnson算法 其中最经典的是Dijkstra算法和Floyd算法。Floyd算法是多源最短路径算法，可以直接求出图中任意两点间的距离，因此只要取其中最大的就可以得到图的直径。 Floyd算法算法思想假设Dis(i,j)为节点u到节点v的最短路径的距离(最短路径长度)，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，说明从i到k再到j的路径比i直接到j的路径短，便记录Dis(i,j) = Dis(i,k) + Dis(k,j)。因此，当遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。 算法特点 使用了动态规划思想 可以计算无向图或有向图 核心代码简短(五行) 可以一次性计算出任意两点间的距离 算法复杂度O(n^3)，是一个好算法 一个关键性问题在判断Dis(i,k) + Dis(k,j) &lt; Dis(i,j)这个公式时，如果经过k的距离更短就选择k，但是这能否保证此时Dis(i,k)和Dis(k,j)已经取得了最小值呢？ 答案是肯定的，可以用数学归纳法证明，参考这篇博客 示例待求直径的图G 程序输入2（表示无向图） 8 9 （表示8个顶点，9条边） 1 2 5 （表示顶点1和顶点2之间的距离权重是5） … … 程序输出（邻接矩阵，矩阵元素M[i][j]表示顶点Vi与Vj间的距离） （各个顶点间的最短路径以及路径长度，对于此例，顶点V4与V6或V8间的距离都是10，是距离最远的两个顶点对） （此图的直径） Python源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# ----------------------------------------------# Project： calculate diameter of graph# Using floyd algorithm# ----------------------------------------------# define function: print shortest pathdef getPath(i, j): if i != j: if path[i][j] == -1: print('-', j+1, end='') else: getPath(i, path[i][j]) getPath(path[i][j], j)def printPath(i, j): print(' Path:', i+1, end='') getPath(i, j) print()print('---------------- Program start ----------------')# read dataflag = input('please input type of graph(1:directed ' 'graph; 2:undirected graph): ')vertex, edge = input('please input the number of ' 'vertex and edge: ').strip().split()# initializedflag = int(flag)vertex = int(vertex)edge = int(edge)inf = 99999999dis = [] # matrix of the shortest distancepath = [] # record the shortest pathfor i in range(vertex): dis += [[]] for j in range(vertex): if i == j: dis[i].append(0) else: dis[i].append(inf)for i in range(vertex): path += [[]] for j in range(vertex): path[i].append(-1)# read weight informationprint('please input weight info(v1 v2 w[v1,v2]): ')for i in range(edge): u, v, w = input().strip().split() u, v, w = int(u)-1, int(v)-1, int(w) if flag == 1: dis[u][v] = w elif flag == 2: dis[u][v] = w dis[v][u] = wprint('the weight matrix is:')for i in range(vertex): for j in range(vertex): if dis[i][j] != inf: print('%5d' % dis[i][j], end='') else: print('%5s' % '∞', end='') print()# floyd algorithmfor k in range(vertex): for i in range(vertex): for j in range(vertex): if dis[i][j] &gt; dis[i][k] + dis[k][j]: dis[i][j] = dis[i][k] + dis[k][j] path[i][j] = kprint('===========================================')# output the resultprint('output the result:')if flag == 1: for i in range(vertex): for j in range(vertex): if (i != j) and (dis[i][j] != inf): print('v%d ----&gt; v%d tol_weight:' '%3d' % (i+1, j+1, dis[i][j])) printPath(i, j) if (i != j) and (dis[i][j] == inf): print('v%d ----&gt; v%d tol_weight:' ' ∞' % (i+1, j+1)) printPath(i, j)if flag == 2: for i in range(vertex): for j in range(i+1, vertex): print('v%d &lt;----&gt; v%d tol_weight:' '%3d' % (i+1, j+1, dis[i][j]), '', end='') printPath(i, j)print()for i in range(vertex): for j in range(vertex): if dis[i][j] == inf: dis[i][j] = 0# max(max(dis)): the max item of two dimension matrixprint('&gt;&gt; the diameter of graph: %d &lt;&lt;' % max(max(dis)))print('-------------- Program end ----------------') Reference 最短路径_百度百科 最短路径—Dijkstra算法和Floyd算法 最短路径问题—Floyd算法详解 - CSDN博客 Floyd算法(记录路径) - CSDN博客]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab更换字体后 中文显示乱码问题]]></title>
    <url>%2F2018%2F06%2F21%2FMATLAB%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93%E5%90%8E%20%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言MATLAB的脚本代码默认宋体显示，对于大多数720P的显示器来说，无论是中文还是英文，显示效果都非常差。Windows环境下，Consolas是一种比较理想的英文代码字体。 Consolas 字体是微软专为程序员开发的一种字体，这一字体的特性是所有字母、数字与符号均能非常容易辨认!而且所有字符都具有相同的宽度,让编程人员看着更舒适。但是不支持中文。 微软雅黑是个人电脑上可以显示的最清晰的中文字体之一,全面支持ClearType技术。 但是在MATLAB 2014b中将默认字体设置修改后，中文注释会出现乱码。解决方案是下载一种 Consolas 和 微软雅黑 的混合字体，这样既保证了代码的显示效果，而且也兼容了中文显示。 解决方案1、下载雅黑Consolas字体混合版 下载链接YAHEI CONSOLAS HYBRID.TTF 2、安装字体 下载后，双击，然后安装字体。 C:\Windows\Fonts文件夹下会出现刚刚安装成功的字体。 3、更改MATLAB的字体设置 打开MATLAB设置项。 然后选择新安装的字体，保存设置 4、查看效果 测试效果，发现中英文皆可正常显示。 Reference matlab字体终极解决方案 - CSDN博客 YaHei Consolas Hybrid(雅黑Consolas字体混合版) v1.12最新版 - 未来软件园]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
</search>
