<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer题解41-50]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A341-50%2F</url>
    <content type="text"><![CDATA[41 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个*数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路 分别使用大顶堆和小顶堆实现数据流的左半边和右半边，左半边的数都小于右半边的数。 堆的插入操作为O(logn)，获取堆顶数据O(1)。每次从数据流中读取一个数据，约定如果是第奇数个，则插入左边的堆，否则插入右边的堆，这样可以使两边的堆平衡，如果数据流总数为奇数个，则中位数就是左边堆的堆顶，如果是偶数个就是左右两个堆堆顶之和的平均值。 在插入式还需要注意，如果是第偶数个，但是其值比左边堆的堆顶还要小，则将其插入到左边，然后再将左边堆的堆顶插入到右边堆保持平衡，同理如果是第奇数个数大于右边堆的最小值，做法一样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.PriorityQueue;/** * 41 数据流中的中位数 * 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个 * 数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 * * 解题思路： * 分别使用大顶堆和小顶堆实现数据流的左半边和右半边，左半边的数都小于右半边的数。堆的插入操作为O(logn)，获取堆顶数据O(1)。每次从数据流中读取一个数据，约定如果是第 * 奇数个，则插入左边的堆，否则插入右边的堆，这样可以使两边的堆平衡，如果数据流总数为奇数个，则中位数就是左边堆的堆顶，如果是偶数个就是 * 左右两个堆堆顶之和的平均值。 * 在插入式还需要注意，如果是第偶数个，但是其值比左边堆的堆顶还要小，则将其插入到左边，然后再将左边堆的堆顶 * 插入到右边堆保持平衡，同理如果是第奇数个数大于右边堆的最小值，做法一样。 */public class _41 &#123; private PriorityQueue&lt;Integer&gt; leftMaxHeap = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o2 - o1)); private PriorityQueue&lt;Integer&gt; rightMinHeap = new PriorityQueue&lt;&gt;(); private int length = 0; public void Insert(Integer num) &#123; length++; if (length == 1) &#123; // 第一个数直接插入即可 leftMaxHeap.add(num); &#125; else &#123; // 如果是第偶数个，插入到右边 if (length % 2 == 0) &#123; if (num &gt;= leftMaxHeap.peek()) &#123; rightMinHeap.add(num); &#125; else &#123; leftMaxHeap.add(num); rightMinHeap.add(leftMaxHeap.poll()); &#125; &#125; else &#123; if (num &lt;= rightMinHeap.peek()) &#123; leftMaxHeap.add(num); &#125; else &#123; rightMinHeap.add(num); leftMaxHeap.add(rightMinHeap.poll()); &#125; &#125; &#125; &#125; public Double GetMedian() &#123; if (length % 2 == 0) &#123; return (leftMaxHeap.peek() + rightMinHeap.peek()) / 2.0; &#125; return Double.valueOf(leftMaxHeap.peek()); &#125;&#125; 42 连续子数组的最大和12345678910111213141516171819202122232425/** * 42 连续子数组的最大和 * 在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数, * 并期望旁边的正数会弥补它呢？例如:&#123;6,-3,-2,7,-15,1,2,2&#125;,连续子向量的最大和为8(从第0个开始,到第3个为止) * * 解题思路： * 设f[i]表示以第i个数字结尾的连续子数组的最大和（第i个数字一定在向量中），则有f[i] = f[i-1] + array[i]，当f[i-1] &gt; 0； * 否则f[i] = array[i]，最终的结果为max&#123; f[i] &#125; */public class _42 &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; if (array == null || array.length == 0) &#123; throw new RuntimeException(); &#125; int[] f = new int[array.length]; f[0] = array[0]; int result = f[0]; for (int i = 1; i &lt; array.length; i++) &#123; f[i] = f[i-1] &lt; 0 ? array[i] : f[i-1] + array[i]; result = Math.max(result, f[i]); &#125; return result; &#125;&#125; 43 从1到n整数中1出现的次数1234567891011121314151617181920212223242526272829/** * 43 从1到n整数中1出现的次数 * 很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数） * * 解题思路： * 当n = 3141592时： * * 当考虑个位，十位，百位这三位为1的情况时： * * 个位2 ，当个位取值1时，前面的六位数字可由0~314159组成，即314160种情况 * 十位9，当十位取值1时，前面的五位数字可由0~31415组成，十位之后的一位可由0~9组成（即xxxxx10 ~ xxxxx19），组合情况31416*10=314160种情况 * 百位5，当百位取值为1时，前面的四位数字可由0~3141组成，百位之后的两位可由0~99组成，组合情况为3142*100=314200种情况 * * * 注意：当考虑千位1时： * 千位1，千位取值即1，前面的三位数字可由0~314组成，但是当前面的值为314时，后面的三位只有0~592种情况(特殊情况)，其余的情况即为前面的值为0~313,后面三位有0~999,情况数为314000，所以总情况数为314000 + 593=314593种情况 * 这时可发现和代码中的公式算的情况是吻合的，a+8的巧妙之处在于当a的最后一位(当前分析位)为0或1时，加8不产生进位，这是为需要单独算的特殊情况做准备，而当前分析位为2~9时，不需要考虑特殊情况，所以允许加8产生的进位。 */public class _43 &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int cnt = 0; for (int m = 1; m &lt;= n; m *= 10) &#123; int a = n / m, b = n % m; cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0); &#125; return cnt; &#125;&#125; 44 数字序列中的某一位数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 44 数字序列中的某一位数字 * 数字以 0123456789101112131415... 的格式序列化到一个字符串中，请写一个函数，求任意第n位对应的数字。 * * 解题思路： * 通过查找规律跳过一些区间 */public class _44 &#123; /** * 先找到所在位置的数字区间，然后调用函数精确找到对应的数字 * @param index 位置 * @return 返回任意第index位对应的数字 */ public int digitAtIndex(int index) &#123; if (index &lt; 0) &#123; return -1; &#125; int lengthOfNum = 1; while (true) &#123; int cnt = lengthOfNum * this.countOfInteger(lengthOfNum); // 调用函数精确找到对应的数字 if (index &lt; cnt) &#123; return this.digitAtIndex(index, lengthOfNum); &#125; // 跳过区间 index -= cnt; lengthOfNum++; &#125; &#125; /** * 精确查找位置 * @param index 相对位置 * @param lengthOfNum 数字长度 * @return 返回对应位置的数字 */ private int digitAtIndex(int index, int lengthOfNum) &#123; int number = this.beginNumber(lengthOfNum) + index / lengthOfNum; // 从右向左查找 int indexFromRight = lengthOfNum - index % lengthOfNum; for (int i = 1; i &lt; indexFromRight; ++i) &#123; number /= 10; &#125; // 返回个位即为所求 return number % 10; &#125; /** * 返回长度为lengthOfNum的所有数字个数(10, 90, 900...) * @param lengthOfNum 数字长度 * @return 长度为lengthOfNum的所有数字个数 */ private int countOfInteger(int lengthOfNum) &#123; if (lengthOfNum == 1) &#123; return 10; &#125; return (int) (9 * Math.pow(10, lengthOfNum - 1)); &#125; /** * 返回长度为lengthOfNum的第一个数字(0, 10, 100...) * @param lengthOfNum 数字长度 * @return 长度为lengthOfNum的第一个数字 */ private int beginNumber(int lengthOfNum) &#123; if (lengthOfNum == 1) &#123; return 0; &#125; return (int) Math.pow(10, lengthOfNum - 1); &#125;&#125; 45 把数组排成最小的数1234567891011121314151617181920212223242526272829import java.util.Arrays;/** * 45 把数组排成最小的数 * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这 * 三个数字能排成的最小数字为321323 * * 解题思路： * 将数字转化为字符串数组，然后排序，根据s1 + s2 和 s2 + s1 拼接后比较大小 */public class _45 &#123; public String PrintMinNumber(int [] numbers) &#123; if (numbers == null || numbers.length == 0) &#123; return ""; &#125; String[] numsOfStr = new String[numbers.length]; for (int i = 0; i &lt; numbers.length; i++) &#123; numsOfStr[i] = String.valueOf(numbers[i]); &#125; // 根据s1 + s2 和 s2 + s1 拼接后比较大小 Arrays.sort(numsOfStr, (String s1, String s2) -&gt; (s1 + s2).compareTo(s2 + s1)); String str = ""; for (String s : numsOfStr) &#123; str += s; &#125; return str; &#125;&#125; 46 把数字翻译成字符串123456789101112131415161718192021222324252627282930313233343536373839/** * 46 把数字翻译成字符串 * 给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共 * 有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法 * Leetcode： https://leetcode.com/problems/decode-ways/description/ * * 解题思路： * 定义函数f(i)表示从第i位数字开始的不同翻译的数目，则有f(i)=f(i+1) + g(i, i+1) * f(i+2)，其中当第i位和第i+1位数字拼接起来的数字在 * 10 ~ 25范围内时，g(i, i+1) = 1，否则g(i, i+1) = 0，分别表示这两个数字单独翻译和一起翻译的情况，从尾部向前开始遍历，存储子问题。 * */public class _46 &#123; public int numDecodings(String s) &#123; if (s == null || s.length() == 0 || s.charAt(0) == '-') &#123; return 0; &#125; // dp[i]表示从第i位开始的不同翻译的数目 int[] dp = new int[s.length() + 1]; // 初始化 dp[s.length()] = 1; dp[s.length() - 1] = 1; // 自尾部向前 for (int i = s.length() - 2; i &gt;= 0; --i) &#123; if (s.substring(i, i + 2).compareTo("10") &gt;= 0 &amp;&amp; s.substring(i, i + 2).compareTo("25") &lt;= 0) &#123; dp[i] = dp[i + 1] + dp[i + 2]; &#125; else &#123; dp[i] = dp[i + 1]; &#125; &#125; return dp[0]; &#125; public static void main(String[] args) &#123; System.out.println(new _46().numDecodings("12258")); System.out.println(new _46().numDecodings("1")); System.out.println(new _46().numDecodings("-123")); &#125;&#125; 47 礼物的最大价值12345678910111213141516171819202122232425262728293031323334353637383940/** * 47 礼物的最大价值 * 在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。你可以从棋盘的左上角开始拿礼格子里的礼物，并每次向右或 * 向下移动一格，直到到达棋盘的右下角。给定一个棋盘和礼物，求你能拿到礼物的最大价值 * * 解题思路： * 典型的动态规划问题 */public class _47 &#123; public int getMaxValue(int[][] gift) &#123; if (gift == null || gift.length == 0 || gift[0].length == 0) &#123; return 0; &#125; int row = gift.length; int col = gift[0].length; int[][] dp = new int[row][col]; dp[0][0] = gift[0][0]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + gift[i][j]; &#125; else if (i == 0 &amp;&amp; j &gt; 0) &#123; dp[i][j] = dp[i][j-1] + gift[i][j]; &#125; else if (i &gt; 0 &amp;&amp; j == 0) &#123; dp[i][j] = dp[i-1][j] + gift[i][j]; &#125; &#125; &#125; return dp[row-1][col-1]; &#125; public static void main(String[] args) &#123; int[][] gift = &#123;&#123;1, 10, 3, 8&#125;, &#123;12, 2, 9, 6&#125;, &#123;5, 7, 4, 11&#125;, &#123;3, 7, 16, 5&#125;&#125;; // output: 53 System.out.println(new _47().getMaxValue(gift)); &#125;&#125; 48 最长不含重复字符的子字符串12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;/** * 48 最长不含重复字符的子字符串 * 寻找最长不含重复字符的子字符串，字符串范围'a'~'z'. * * 解题思路： * 定义函数f(i)为以第i个字符为结尾的不包含重复字符的子字符串的最长长度（第i个字符一定在这个最长不重复的子串中），则有一下三种情况： * 1、第i个字符之前没出现过，则有递推关系f(i) = f(i-1) + 1; * 2、第i个字符之前出现过，且与上次出现位置的距离为d，若 d&lt;=f(i-1)，说明这个字符一定出现在f(i-1)对应的最长不重复的子串中，因此有f(i) = d; * 3、若 d&gt;f(i-1)，说明这个字符不在f(i-1)对应的最长不重复的子串中，因此有f(i) = f(i-1) + 1; * 最终结果为max_i &#123;f(i)&#125; */public class _48 &#123; public int longestSubStringWithoutDuplication(String str) &#123; int curLength = 0; // f(i) int maxLength = 0; // final result int[] position = new int[26]; // record position Arrays.fill(position, -1); // init for (int curIndex = 0; curIndex &lt; str.length(); curIndex++) &#123; // 获取当前字符之前出现过的位置preIndex，如果没出现过则为-1 int preIndex = position[str.charAt(curIndex) - 'a']; // 第i个字符之前没出现过，或者 d&gt;f(i-1)，有f(i) = f(i-1) + 1 if (preIndex == -1 || curIndex - preIndex &gt; curLength) &#123; curLength++; &#125; else &#123; // d&lt;=f(i-1),f(i)=d， 此时f(i)相对于f(i-1)(即curLength)会减小，需要记录为maxLength maxLength = Math.max(maxLength, curLength); // f(i)=d curLength = curIndex - preIndex; &#125; // 存储当前字符的位置 position[str.charAt(curIndex) - 'a'] = curIndex; &#125; // 更新结果 maxLength = Math.max(maxLength, curLength); return maxLength; &#125;&#125; 49 丑数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 49 丑数 * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。 * 求按从小到大的顺序的第N个丑数 * * 解题思路一： * 依次判断每一个整数是否为丑数，直到找到目标丑数 * * 解题思路二： * 以较小的空间换取时间，通过不断生成排序的丑数序列，直接找到目标丑数。其中，后一个丑数一定是前面某一个丑数乘以2，3，5得到的，大于当前 * 丑数且尽量小，记录前面这个丑数的位置，每次更新后一个丑数时，更新这个位置即可。 */public class _49 &#123; public int GetUglyNumber_Solution2(int index) &#123; if (index &lt;= 0) &#123; return 0; &#125; int[] dp = new int[index]; int i2 = 0, i3 = 0, i5 = 0; dp[0] = 1; for (int i = 1; i &lt; index; i++) &#123; dp[i] = Math.min(dp[i2] * 2, Math.min(dp[i3] * 3, dp[i5] * 5)); if (dp[i] == dp[i2] * 2) &#123; i2++; &#125; if (dp[i] == dp[i3] * 3) &#123; i3++; &#125; if (dp[i] == dp[i5] * 5) &#123; i5++; &#125; &#125; return dp[index - 1]; &#125; public int GetUglyNumber_Solution1(int index) &#123; int number = 0; int uglyIndex = 0; while (uglyIndex &lt; index) &#123; number++; if (this.isUglyNumber(number)) &#123; uglyIndex++; &#125; &#125; return number; &#125; private boolean isUglyNumber(int number) &#123; while (number % 2 == 0) &#123; number /= 2; &#125; while (number % 3 == 0) &#123; number /= 3; &#125; while (number % 5 == 0) &#123; number /= 5; &#125; return number == 1; &#125; public static void main(String[] args) &#123; System.out.println(new _49().GetUglyNumber_Solution1(10)); System.out.println(new _49().GetUglyNumber_Solution2(10)); &#125;&#125; 50 第一个只出现一次的字符位置12345678910111213141516171819202122232425/** * 50 第一个只出现一次的字符位置 * 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写） * * 解题思路： * 先扫描一次，将每个字符出现的次数统计到数组中，第二次扫描找出第一个只出现一次的字符。 */public class _50 &#123; public int FirstNotRepeatingChar(String str) &#123; if (str == null || str.length() == 0) &#123; return -1; &#125; int[] hashTable = new int[256]; for (char c : str.toCharArray()) &#123; hashTable[(int) c]++; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; if (hashTable[str.charAt(i)] == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解31-40]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A331-40%2F</url>
    <content type="text"><![CDATA[31 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路： 使用一个辅助堆栈，输入参数为数组1（入栈序列）和数组2（出栈序列），在每次循环中，先入栈一个数字，数组1索引后移一位， 避免堆栈为空，然后判断栈顶元素和数组2当前要出栈的数字是否相同，如果是则pop一次，数组2索引后移一次，继续循环判断，循环过程中 要注意数组2不能溢出，堆栈不能为空，如果不相等则跳出第二个循环，继续外围循环，入栈再判断 123456789101112131415161718192021222324252627282930import java.util.Stack;/** * 31 栈的压入、弹出序列 * 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。 * 例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。 * （注意：这两个序列的长度是相等的） * * 解题思路：使用一个辅助堆栈，输入参数为数组1（入栈序列）和数组2（出栈序列），在每次循环中，先入栈一个数字，数组1索引后移一位， * 避免堆栈为空，然后判断栈顶元素和数组2当前要出栈的数字是否相同，如果是则pop一次，数组2索引后移一次，继续循环判断，循环过程中 * 要注意数组2不能溢出，堆栈不能为空，如果不相等则跳出第二个循环，继续外围循环，入栈再判断 */public class _31 &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if (pushA.length == 0 || popA.length == 0) &#123; return false; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0, j = 0; i &lt; popA.length; ++i) &#123; stack.push(pushA[i]); // 注意堆栈判空 while (j &lt; popA.length &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popA[j]) &#123; stack.pop(); j++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 32 从上往下打印二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import java.util.*;/** * 32 从上往下打印二叉树 * 题目一：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 * 解题思路：BFS * * 题目二：把二叉树打印成多行 * 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 * 解题思路： * 设置全局变量lastNode将每行的最后一个节点存储起来，当遍历到该节点时，在添加其所有子节点后，将队列的最后一个节点保存到lastNode中， * 这是作为下一层的最后一个节点 * * 题目三：按之字形顺序打印二叉树 * 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印， * 其他行以此类推。 * 解题思路： * 在题目二的基础上，对偶数层的list进行反转即可；也可以使用两个堆栈，在奇数层和偶数层分别push左、右节点和右、左节点 */public class _32 &#123; /** * 从上往下打印二叉树 * @param root 根节点 * @return 打印顺序值 */ public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); if (root == null) &#123; return arrayList; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); arrayList.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; return arrayList; &#125; /** * 把二叉树打印成多行 * @param pRoot 根节点 * @return 打印的二维数组 */ ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (pRoot == null) &#123; return arrayList; &#125; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); TreeNode lastNode = pRoot; while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; // 判断是否是一层的最后一个节点，如果是则储存下一层的最后一个节点 if (node == lastNode) &#123; lastNode = queue.peekLast(); // 此处注意不能直接将list添加到arrayList中，否则后面的clear操作会清空对应的栈区 arrayList.add(new ArrayList&lt;&gt;(list)); list.clear(); &#125; &#125; return arrayList; &#125; /** * 把二叉树打印成多行 * @param pRoot 根节点 * @return 打印的二维数组 */ ArrayList&lt;ArrayList&lt;Integer&gt;&gt; print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 奇偶标志 boolean flag = false; if (pRoot == null) &#123; return arrayList; &#125; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); TreeNode lastNode = pRoot; while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; // 判断是否是一层的最后一个节点，如果是则储存下一层的最后一个节点 if (node == lastNode) &#123; lastNode = queue.peekLast(); // 此处注意不能直接将list添加到arrayList中，否则后面的clear操作会清空对应的栈区 if (flag) &#123; Collections.reverse(list); &#125; arrayList.add(new ArrayList&lt;&gt;(list)); flag = !flag; list.clear(); &#125; &#125; return arrayList; &#125; /** * 二叉树结构 */ public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 33 二叉搜索树的后序遍历序列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 33 二叉搜索树的后序遍历序列 * 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字 * 都互不相同。 * * 解题思路： * 二叉搜索树，后序遍历，根节点在最后一个，左子树所有节点小于根节点，右子树所有节点大于根节点，针对仅有左子树、仅有右子树和左右 * 子树都存在这三种情况，进行递归 */public class _33 &#123; public static boolean VerifySquenceOfBST(int [] sequence) &#123; if (sequence == null || sequence.length == 0) &#123; return false; &#125; return verifySquenceOfBST(sequence, 0, sequence.length - 1); &#125; /** * 递归判断 * @param sequence 待判序列 * @param start 当前树的后续遍历序列开始位置 * @param end 当前树的后续遍历序列结束位置 * @return 是否是二叉搜索树的后续遍历序列 */ private static boolean verifySquenceOfBST(int [] sequence, int start, int end) &#123; if (start == end) &#123; return true; &#125; // 找到右子树开始的位置，sequence[end]是根节点 int index = -1; for (int i = 0; i &lt; end; ++i) &#123; if (sequence[i] &gt; sequence[end]) &#123; index = i; break; &#125; &#125; // 如果只有左子树，没有右子树(所有节点都比根节点小，index没有被赋值) if (index == -1) &#123; return verifySquenceOfBST(sequence, start, end - 1); &#125; // 如果有右子树，判断右子树所有节点是否都大于根节点 for (int i = index + 1; i &lt; end; ++i) &#123; if (sequence[i] &lt; sequence[end]) &#123; return false; &#125; &#125; // 如果仅有右子树，没有左子树(从第0个值就开始比根节点大) if (index == 0) &#123; return verifySquenceOfBST(sequence, index, end - 1); &#125; // 左、右子树均存在 return verifySquenceOfBST(sequence, start, index - 1) &amp;&amp; verifySquenceOfBST(sequence, index, end - 1); &#125; public static void main(String[] args) &#123; int[] sequence1 = &#123;5, 7, 6, 9, 11, 10, 8&#125;; int[] sequence2 = &#123;1, 2, 5, 3&#125;; int[] sequence3 = &#123;1, 2, 3, 4, 5&#125;; int[] sequence4 = &#123;7, 4, 6, 5&#125;; System.out.println(VerifySquenceOfBST(sequence1)); System.out.println(VerifySquenceOfBST(sequence2)); System.out.println(VerifySquenceOfBST(sequence3)); System.out.println(VerifySquenceOfBST(sequence4)); &#125;&#125; 34 二叉树中和为某一值的路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;/** * 34 二叉树中和为某一值的路径 * 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的 * 结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) * * 解题思路： * 使用前序遍历二叉树，每次访问到一个子树根节点时，就将其加入到路径列表中，接着判断当前路径是否符合要求（没有子节点且路径和等于目标值）， * 如果符合则将该路径加到列表中，否则继续遍历其子节点。当前节点访问结束后，递归函数将回溯到其父节点，因此要将当前节点从列表中删除 */public class _34 &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; if (root == null) &#123; return arrayLists; &#125; // 假设当前节点在路径中，则将当前子树的根节点加到列表中 list.add(root.val); target -= root.val; // 如果已经找到了满足条件的路径，则添加路径到列表中 if (target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; arrayLists.add(new ArrayList&lt;&gt;(list)); &#125; // 否则继续在子树中寻找(如果找到了会将路径加到arrayLists列表中) FindPath(root.left, target); FindPath(root.right, target); // 回溯到父节点(将当前节点从列表中移除) list.remove(list.size() - 1); // 返回路径列表 return arrayLists; &#125; /** * 二叉树结构 */ public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 35 复杂链表的复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * 35 复杂链表的复制 * 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂 * 链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） * * 解题思路一： * 1、复制链表，将复制的节点放置于原节点的后面，呈A-A'-B-B'-C-C'排布 * 2、根据原链表的指向关系，操作复制链表的指向 * 3、拆分两个链表 * * 解题思路二： * 1、复制链表，并使用一个HashMap，key为原节点，value为复制的节点 * 2、设置random的指向，复制节点的random指向为：Map&#123; key = 相同位置原节点的random指向&#125; */public class _35 &#123; public static RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) &#123; return null; &#125; // 复制链表，将复制的节点放置于原节点的后面，呈A-A'-B-B'-C-C'排布 RandomListNode curNode = pHead; while (curNode != null) &#123; RandomListNode copyNode = new RandomListNode(curNode.label); RandomListNode nextNode = curNode.next; curNode.next = copyNode; copyNode.next = nextNode; curNode = nextNode; &#125; // 根据原链表的指向关系，操作复制链表的指向 curNode = pHead; while (curNode != null) &#123; if (curNode.random != null) &#123; curNode.next.random = curNode.random.next; &#125; curNode = curNode.next.next; &#125; // 拆分两个链表 curNode = pHead; RandomListNode node = pHead.next; while (curNode.next != null) &#123; RandomListNode nextNode = curNode.next; curNode.next = nextNode.next; curNode = nextNode; &#125; return node; &#125; public static void main(String[] args) &#123; RandomListNode node1 = new RandomListNode(1); RandomListNode node2 = new RandomListNode(2); RandomListNode node3 = new RandomListNode(3); RandomListNode node4 = new RandomListNode(4); RandomListNode node5 = new RandomListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = null; node1.random = node3; node2.random = node5; node4.random = node2; RandomListNode node = Clone(node1); while (node != null) &#123; System.out.println("-----------------------"); System.out.println("node.label:" + node.label); if (node.next != null) &#123; System.out.println("node.next:" + node.next.label); &#125; if (node.random == null) &#123; System.out.println("node.random:" + "null"); &#125; else &#123; System.out.println("node.random:" + node.random.label); &#125; node = node.next; &#125; &#125; public static class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125; &#125;&#125; 36 二叉搜索树与双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 36 二叉搜索树与双向链表 * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向 * * 解题思路： * 对于二叉搜索树，中序遍历正好是升序，每次将遍历到的节点加入到双向链表中即可，需要记录双向链表的位置 */public class _36 &#123; private TreeNode left = null; private TreeNode right = null; /** * 中序遍历,每次将遍历到的节点加入到双向链表中 * @param pRootOfTree 当前子树的根节点 * @return 返回双向链表的头节点 */ public TreeNode Convert(TreeNode pRootOfTree) &#123; if (pRootOfTree == null) &#123; return null; &#125; // 对左子树中序遍历,每次将遍历到的节点加入到双向链表中 Convert(pRootOfTree.left); if (right == null) &#123; // 第一次遍历到树的最左边的叶子节点时(即可确定双向链表最左边的头节点) left = pRootOfTree; &#125; else &#123; // 将当前遍历的根节点加入到双向链表的末端 right.right = pRootOfTree; pRootOfTree.left = right; &#125; // 同时更新双向链表的最右端节点的位置 right = pRootOfTree; // 对右子树中序遍历,每次将遍历到的节点加入到双向链表中 Convert(pRootOfTree.right); return left; &#125; /** * 二叉树结构 */ public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 37 序列化二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 37 序列化二叉树 * 请实现两个函数，分别用来序列化和反序列化二叉树 */public class _37 &#123; private String str = ""; private int index = 0; public String Serialize(TreeNode root) &#123; if (root == null) &#123; str += "$,"; return null; &#125; str += (String.valueOf(root.val) + ","); Serialize(root.left); Serialize(root.right); return str.substring(0, str.length() - 1); &#125; public TreeNode Deserialize(String str) &#123; if (str == null || str.length() == 0) &#123; return null; &#125; String[] strArray = str.split(","); return deserializeCore(strArray); &#125; private TreeNode deserializeCore(String[] strArray) &#123; // 当前节点不为空时，会继续重建左右子树，否则返回null if (!strArray[index].equals("$")) &#123; TreeNode treeNode = new TreeNode(Integer.valueOf(strArray[index++])); treeNode.left = deserializeCore(strArray); treeNode.right = deserializeCore(strArray); return treeNode; &#125; else &#123; index++; return null; &#125; &#125; public static void main(String[] args) &#123; TreeNode t1 = new TreeNode(1); TreeNode t2 = new TreeNode(2); TreeNode t3 = new TreeNode(3); t1.left = t2; t1.right = t3; // 序列化 System.out.println(new _37().Serialize(t1)); // 反序列化 TreeNode root = new _37().Deserialize(new _37().Serialize(t1)); System.out.println(root.val); System.out.println(root.left.val); System.out.println(root.right.val); &#125; /** * 二叉树结构 */ public static class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 38 字符串的排列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.Collections;/** * 字符串的排列 * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac, * bca,cab和cba。 */public class _38 &#123; private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;String&gt; Permutation(String str) &#123; if (str != null &amp;&amp; str.length() &gt; 0) &#123; // 递归，将全排列加到列表中 this.permutation(str.toCharArray(), 0); // 按字典序排序 Collections.sort(arrayList); &#125; return arrayList; &#125; private void permutation(char[] charArray, int index) &#123; // 当索引和数组长度一致时，将此时顺序的数组转成字符串加到列表中 if (index == charArray.length - 1) &#123; // 避免重复 if (!arrayList.contains(String.valueOf(charArray))) &#123; arrayList.add(String.valueOf(charArray)); &#125; &#125; else &#123; // 将字符数组的第一位(从索引开始)与后面字符不断交换 for (int i = index; i &lt; charArray.length; ++i) &#123; this.swap(charArray, i, index);// // 如果要打印出所有的组合// if (!arrayList.contains(String.valueOf(charArray))) &#123;// arrayList.add(String.valueOf(charArray).substring(0, index + 1));// &#125; this.permutation(charArray, index + 1); this.swap(charArray, i, index); &#125; &#125; &#125; private void swap(char[] charArray, int i, int j) &#123; char temp = charArray[i]; charArray[i] = charArray[j]; charArray[j] = temp; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; arrayList = new _38().Permutation("abc"); for (String str : arrayList) &#123; System.out.println(str); &#125; &#125;&#125; 39 数组中出现次数超过一半的数字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.time.temporal.Temporal;/** * 39 数组中出现次数超过一半的数字 * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组中 * 出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0 * * 解题思路： * 根据题意，如果有一个数字出现的次数超过数组长度的一半，则超过了其他所有数字出现次数的和。使用两个变量，分别记录数组的元素和该元素 * 出现的次数，遍历数组，如果与记录的数字相同，则次数加一，否则次数减一，当次数减为0时，则重新记录当前数字，设置次数为1，继续遍历。 * 当数组遍历结束后，如果记录的次数为0则说明肯定不存在一个数出现的次数超过数组长度的一半，直接返回0；如果记录的次数大于0，说明记录的 * 数字出现的次数可能超过数组长度的一半，因此要重新遍历数组判断是否满足条件，最终时间复杂度和空间复杂度都为O(n). */public class _39 &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if (array == null || array.length == 0) &#123; return 0; &#125; // 分别记录数组的元素和该元素出现的次数 int number = array[0]; int count = 1; // 遍历数组，如果与记录的数字相同，则次数加一，否则次数减一，当次数减为0时，则重新记录当前数字，设置次数为1 for (int i = 1; i &lt; array.length; ++i) &#123; if (array[i] == number) &#123; ++count; &#125; else &#123; if (count &gt; 0) &#123; --count; &#125; else &#123; number = array[i]; count = 1; &#125; &#125; &#125; // 如果记录的次数为0则说明肯定不存在一个数出现的次数超过数组长度的一半 if (count == 0) &#123; return 0; &#125; // 重新遍历数组判断是否满足条件 count = 0; for (int val : array) &#123; if (val == number) &#123; ++count; &#125; &#125; return count &gt; array.length / 2 ? number : 0; &#125;&#125; 40 最小的K个数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.ArrayList;import java.util.PriorityQueue;/** * 40 最小的K个数 * 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4 * * 解题思路一： * 维护一个大小为k的大顶堆，然后遍历n个整数，如果当前数比大顶堆中的最大数小，则替换，否则继续遍历。对堆的操作时间是O(logk)， * 通过PriorityQueue实现，总的时间复杂度为O(nlogk)。适合处理海量数据，不需要将所有数据都读入内存中。 * * 解题思路二： * 利用快排的思想，根据Partition函数返回的下标位置pivot，如果等于k-1（前k-1个数都小于第k个小于第k+1个），说明前k个数已经是最小的了； * 如果pivot大于k-1，则在前pivot-1下标的数中继续寻找，否则在后pivot+1下标的数中寻找。 */public class _40 &#123; /** * 解题思路一 * @param input 输入数组 * @param k K个数 * @return 返回最小的K个数列表 */ public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if (input == null || k &lt;= 0 || k &gt; input.length) &#123; return new ArrayList&lt;&gt;(); &#125; // 维护一个size为k的大顶堆 PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(k, ((o1, o2) -&gt; o2 - o1)); for (int num : input) &#123; if (maxHeap.size() &lt; k) &#123; maxHeap.add(num); &#125; else &#123; if (num &lt; maxHeap.peek()) &#123; maxHeap.poll(); maxHeap.add(num); &#125; &#125; &#125; return new ArrayList&lt;&gt;(maxHeap); &#125; /** * 解题思路二 * @param input 输入数组 * @param k K个数 * @return 返回最小的K个数列表 */ public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution2(int [] input, int k) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); if (input == null || k &lt;= 0 || k &gt; input.length) &#123; return arrayList; &#125; int low = 0; int high = input.length - 1; int pivot = this.Partition(input, low, high); // 如果pivot大于k-1，则在前pivot-1下标的数中继续寻找，否则在后pivot+1下标的数中寻找 while (pivot != k - 1) &#123; if (pivot &gt; k - 1) &#123; high = pivot - 1; &#125; else &#123; low = pivot + 1; &#125; pivot = this.Partition(input, low, high); &#125; // 此时pivot已经等于k-1，前k个数已经是最小的了 for (int i = 0; i &lt; k; ++i) &#123; arrayList.add(input[i]); &#125; return arrayList; &#125; // 使pivotKey左边的数都小于input[pivotKey]，右边的数都大于input[pivotKey] private int Partition(int[] input, int low, int high) &#123; int pivotKey = input[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; pivotKey &lt; input[high]) &#123; high--; &#125; swap(input, pivotKey, high); while (low &lt; high &amp;&amp; input[low] &lt; pivotKey) &#123; low++; &#125; swap(input, low, pivotKey); &#125; return pivotKey; &#125; // 交换数组中下标a和b的位置 private void swap(int[] input, int a, int b) &#123; int temp = input[a]; input[a] = input[b]; input[b] = temp; &#125; public static void main(String[] args) &#123; int[] input = &#123;4, 5, 1, 6, 2, 7, 3, 8&#125;; int k = 4; ArrayList&lt;Integer&gt; arrayList = new _40().GetLeastNumbers_Solution2(input, k); for (Integer integer : arrayList) &#123; System.out.print(integer + " "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（十） 订单管理模块开发]]></title>
    <url>%2F2018%2F12%2F29%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E5%8D%81)%20%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[订单管理接口设计 前台订单管理接口 链接 后台订单管理接口 链接 创建订单 控制器中传入参数为session和收货地址ID，首先校验用户是否登录，如果是则将用户id和shippingId交给服务层控制函数处理； 服务层处理函数首先根据userId查询购物车表，得到购物车中已勾选的商品明细，然后遍历得到订单总价（前提要校验产品售卖状态和库存），转换为订单明细的列表，再生成订单Order（订单号的生成方式是currentTime + new Random().nextInt(100)，避免重复，后续可以更详细的对订单号的生成方式进行编排），接着遍历订单明细的列表，给每个订单明细OrderItem添加订单号，之后将订单明细列表批量插入到order_item表中 123456789101112&lt;insert id="batchInsert" parameterType="list"&gt; insert into mmall_order_item (id, order_no,user_id, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values &lt;foreach collection="orderItemList" index="index" item="item" separator=","&gt; ( #&#123;item.id&#125;,#&#123;item.orderNo&#125;,#&#123;item.userId&#125;,#&#123;item.productId&#125;,#&#123;item.productName&#125;,#&#123;item.productImage&#125;,#&#123;item.currentUnitPrice&#125;,#&#123;item.quantity&#125;,#&#123;item.totalPrice&#125;,now(),now() ) &lt;/foreach&gt;&lt;/insert&gt; 通过购物车商品生成订单后，将产品库存减少，并清空购物车中已选的商品 返回给前端的订单数据还需要进一步装配，将Order和OrderItemList装配成OrderVo返回即可 取消订单 控制器中传入参数为session和订单号orderNo，首先校验用户是否登录，如果是则将用户id和orderNo交给服务层控制函数处理； 服务层处理函数首先根据userId和orderNo查询数据库中的对应订单order，判断订单是否存在，判断订单状态是否为已支付，如果订单存在且未支付，则更新订单状态为CANCELED，更新到数据库订单列表中，返回成功 获取订单商品信息 控制器中传入参数为session，首先校验用户是否登录，如果是则将用户id交给服务层控制函数处理； 服务层处理函数中首先根据userId查询购物车中已勾选商品的明细列表cartList，然后转换成订单明细列表orderItemList，再转换成orderItemVo的列表orderItemVoList，并计算订单商品总价，根据以上信息装配orderProductVo，作为ServerResponse的data返回即可 获取订单详情 控制器中传入参数为session和订单号orderNo，首先校验用户是否登录，如果是则将用户id和orderNo交给服务层控制函数处理； 服务层处理函数根据userId和orderNo查询数据库订单表，判断订单order是否存在，然后再根据userId和orderNo查询数据库订单明细表，得到订单明细列表orderItemList，然后根据order和orderItemList装配orderVo，作为ServerResponse的data返回 获取用户订单分页列表 控制器中传入参数为session、pageNum、pageSize，首先校验用户是否登录，如果是则将用户id和pageNum、pageSize交给服务层控制函数处理； 服务层处理函数仅根据userId查询数据库订单表，得到订单的列表orderList，然后装配成orderVo的列表orderVoList，作为分页信息的列表，最后将分页信息pageInfo作为ServerResponse的data返回即可 12345678910public ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId, int pageNum, int pageSize) &#123; PageHelper.startPage(pageNum, pageSize); List&lt;Order&gt; orderList = orderMapper.selectByUserId(userId); List&lt;OrderVo&gt; orderVoList = assembleOrderVoList(orderList, userId); PageInfo pageInfo = new PageInfo(orderList); pageInfo.setList(orderVoList); return ServerResponse.createBySuccess(pageInfo);&#125; 管理员获取用户订单分页列表 与上面类似，不同之处在于控制器中需要判断是否是管理员，服务层查订单表不需要userId，把全部订单表都查出来，分页即可 12345678910public ServerResponse&lt;PageInfo&gt; manageList(int pageNum, int pageSize) &#123; PageHelper.startPage(pageNum, pageSize); List&lt;Order&gt; orderList = orderMapper.selectAllOrder(); List&lt;OrderVo&gt; orderVoList = assembleOrderVoList(orderList, null); PageInfo pageInfo = new PageInfo(orderList); pageInfo.setList(orderVoList); return ServerResponse.createBySuccess(pageInfo);&#125; 管理员获取订单详情 与普通用户查看订单详情类似，传入参数为session和订单号orderNo，不同之处在于控制器中需要判断是否是管理员，查询数据库时不需要传入userId 管理员按订单号查询 与管理员获取订单详情类似，传入参数为session和订单号orderNo，不同之处在于还要添加分页分页参数，为后续的模糊匹配查询作准备 管理员订单发货 控制器中传入参数为session和订单号orderNo，首先校验用户是否登录，判断管理员权限，如果是则将orderNo交给服务层控制函数处理； 服务层处理函数根据orderNo查询数据库订单表，判断订单是否存在，再判断订单状态是否为已支付，如果是则更新状态为SHIPPED，并同时更新发货时间，更新到数据库中，返回“发货成功”]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（九） 支付模块开发]]></title>
    <url>%2F2018%2F12%2F28%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E4%B9%9D)%20%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[支付接口设计 支付接口 链接 沙箱环境 沙箱环境使用说明 沙箱平台登录 生成RSA密钥 线上创建应用 蚂蚁沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑 Alipay扫码支付 当面付产品介绍 扫码支付接入指引 当面付异步通知 当面付快速接入 当面付SDK&amp;Demo 服务端SDK 关键入参 关键入参 参数说明 out_trade_no 商户订单号 subject 订单标题 total_amount 订单金额 store_id 商户门店编号 timeout_express 交易超时时间 buyer_pay_amount 付款金额 trade_status 交易状态 关键出参 关键入参 参数说明 qr_code 订单二维码图片地址 交易状态说明 枚举名称 枚举说明 WAIT_BUYER_PAY 交易创建，等待买家付款 TRADE_CLOSED 未付款交易超时关闭，或支付完成后全额退款 TRADE_SUCCESS 交易支付成功 TRADE_FINISHED 交易结束，不可退款 通知触发条件 触发条件名 触发条件描述 触发条件默认值 TRADE_FINISHED 交易完成 false（不触发通知） TRADE_SUCCESS 支付成功 true（触发通知） WAIT_BUYER_PAY 交易创建 false（不触发通知） TRADE_CLOSED 交易关闭 false（不触发通知） 支付渠道说明 支付渠道代码 支付渠道 COUPON 支付宝红包 ALIPAYACCOUNT 支付宝余额 POINT 集分宝 DISCOUNT 折扣券 PCARD 预付卡 FINANCEACCOUNT 余额宝 MCARD 商家储值卡 MDISCOUNT 商户优惠券 MCOUPON 商户红包 PCREDIT 蚂蚁花呗 当面付Demo调试 首先进入网址下载当面付的SDK和Demo 下载后解压，将TradePayDemo项目导入到IDEA中，并添加好\TradePaySDK\lib下的jar包 接下来配置属性文件zfbinfo.properties 生成RSA密钥，进入网址下载RSA签名验签工具，解压打开文件夹，运行“RSA签名验签工具.bat”（WINDOWS） ，生成私钥与公钥，如下图： 登录沙箱，将生成的商户应用公钥填入到沙箱RSA2(SHA256)密钥项，同时设置应用网关为https://openapi.alipaydev.com/gateway.do ，授权回调地址为http://www.happymmall.com/order/alipay_callback ，点击AES密钥项，自动生成一个密钥 配置属性文件zfbinfo.properties，与沙箱中的项目一一对应，其他项默认： | 配置文件 | 沙箱 || —————– | ————————- || open_api_domain | 支付宝网关 || pid | 商户UID || appid | APPID || private_key | RSA签名验签工具生成的私钥 || public_key | RSA签名验签工具生成的公钥 || alipay_public_key | 查看支付宝公钥 | 之后再运行主函数Main.java（测试当面付2.0生成支付二维码），从日志中可以看到demo运行成功，生成了一笔订单 复制qr_code后面的网址，进入草料二维码生成页面，粘贴网址，可以生成付款码 下载安装沙箱钱包安卓版，分别使用买家账号扫码支付，使用卖家账号登录查看余额，可以观察到交易成功 将项目部署成Web项目： 运行项目 移植到项目中调试 将原demo中的前缀为alipay的jar包复制到项目工程/webapp/WEB-INF/lib下，并将其他几个公共的jar包添加到maven配置文件中（版本保持一致，避免冲突），在项目结构-模块-依赖设置中，添加lib文件下的jar包； 在maven的pom文件中添加编译插件，可以将lib下的jar包打包发布： 1234567891011121314&lt;!-- maven的核心插件之-complier插件默认只支持编译Java 1.4，因此需要加上支持高版本jre的配置，在pom.xml里面加上 增加编译插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!--将支付宝的sdk放到lib中--&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; 在项目工程中建立com.alipay.demo.trade包，并将demo中的两个java源文件复制过来 运行项目工程中的Main.java，可以看到下单成功； 生成订单和付款码 控制器中传入参数为HttpSession session, 订单号Long orderNo和HttpServletRequest request，session用于校验用户是否登录，request可以获取上传路径，将参数userId、path、orderNo交由服务层处理； 服务层处理函数首先根据订单号和用户ID查询数据库，校验前端传过来的订单是否存在，如果存在则将订单号放到Map中； 接下来将SDK中的当面付2.0生成支付二维码函数main.test_trade_precreate()里面的代码移植到服务层处理函数中，修改相关的订单生成参数，其中商品明细列表通过在for循环中，根据userId和orderNo查表order_item得到 之后创建扫码支付请求builder，然后得到订单创建结果，如果成功则生成图片二维码，并上传到FTP服务器中，将二维码的url放到Map中，将Map作为ServerResponse的data返回；失败则返回对应的错误消息 支付宝回调验签 当收银台调用预下单请求API生成二维码展示给用户后，用户通过手机扫描二维码进行支付，支付宝会将该笔订单的变更信息，沿着商户调用预下单请求时所传入的通知地址主动推送给商户，其中包含了多项参数，程序需要做的就是： 验证异步通知是不是支付宝发过来的，通过SDK中的AlipaySignature.rsaCheckV2()方法，需要在通知返回参数列表中，先除去sign(sdk中已经移除)、sign_type两个参数 对通知中的信息进行校验，同时要避免重复通知，官方文档的提示： 商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，并判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），同时需要校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方（有的时候，一个商户可能有多个seller_id/seller_email），上述有任何一个验证不通过，则表明本次通知是异常通知，务必忽略。在上述验证通过后商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。在支付宝的业务通知中，只有交易通知状态为TRADE_SUCCESS或TRADE_FINISHED时，支付宝才会认定为买家付款成功 给支付宝服务器返回处理信息，否则支付宝服务器会不断重复发送通知 程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟 控制器中传入参数为HttpServletRequest request，从request中获取Map参数，需要将Map&lt;String, String[]&gt; –&gt; Map&lt;String, String&gt; 以便于作为后面的验签参数； 接下来验证回调的正确性，是否来自于支付宝，要先移除sign_type参数： 12345678910// 除去sign(sdk中已经移除)、sign_type两个参数，对其他参数进行验签params.remove("sign_type");try &#123; boolean alipayRSACheckedV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), "utf-8", Configs.getSignType()); if (!alipayRSACheckedV2) &#123; return ServerResponse.createByErrorMessage("非法请求，验证不通过!!!"); &#125;&#125; catch (AlipayApiException e) &#123; logger.info("支付宝回调异常", e);&#125; 接下来将Map&lt;String, String&gt;作为参数交给服务层处理，对其中的参数进行校验； 首先从参数中获取商户订单号orderNo、支付宝流水号tradeNo、交易状态tradeStatus； 查询数据库校验是否是商户订单号，如果不是返回“非法”，如果是则校验订单状态，再检验交易状态(如果交易成功则更新数据库中订单状态和付款时间)，然后存储支付信息PayInfo到数据库中； 最后在控制器中给支付宝服务器返回处理信息： 123456// 验证各种数据并返回给支付宝服务器通知ServerResponse serverResponse = iOrderService.aliCallback(params);if(serverResponse.isSuccess()) &#123; return Const.AlipayCallback.RESPONSE_SUCCESS;&#125;return Const.AlipayCallback.RESPONSE_FAILED; 查询订单支付状态 控制器中传入参数为session和订单号，首先校验用户是否登录，如果是则将用户id和订单号交给服务层控制函数处理； 服务层控制函数根据用户id和订单号查询数据库，如果查不到则返回“用户没有订单”，否则继续校验订单状态，如果是已支付（在支付宝回调验证中，如果付款成功会更新数据库订单的状态）则返回成功，否则返回错误 Ngrok 内网穿透一般情况下，本机IP是内网IP，无法从外网访问本机，当把tomcat web工程部署到8080端口后，也只能从本机局域网访问，这样就无法接收到支付宝的回调通知，内网穿透可以使外网访问到局域网内的本机。 常用的内网穿透软件有花生壳、NatApp、Ngrok等，这里使用免费的Ngrok。 详细的Ngrok编译方法参见链接 免费的Ngrok客户端下载地址 下载客户端，解压，运行启动脚本 输入自定义的三级域名前缀，如“cr” 输入绑定的本机端口，如“8080” 启动成功后，部署好本地web工程，从外网访问“http://cr.ngrok.xiaomiqiu.cn/ ”即可 如果要自定义域名，需要先将自己的域名解析到120.78.180.104，然后执行 1ngrok -config=ngrok.cfg -hostname xxx.xxx.xxx 8080 功能测试 启动Tomcat http://localhost:8080/ 启动FTP ftp://127.0.0.1/ （绑定21端口） 启动Nginx http://localhost/ （默认80端口） http://image.imooc.com/1.png 启动Ngrok http://cr.ngrok.xiaomiqiu.cn/ （绑定本机8080端口） 修改属性文件中的alipay.callback.url，以便于本机能接收到支付宝回调通知： 1alipay.callback.url=http://cr.ngrok.xiaomiqiu.cn/order/alipay_callback 测试pay接口（传入的订单号和userId要在数据库中存在，并且支付状态为未支付）能否生成订单并上传二维码，返回二维码的url 然后使用沙箱支付宝扫码支付，查看买卖双方的账单 使用query_order_pay_status接口查看支付前后的订单状态]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（八） 收货地址模块开发]]></title>
    <url>%2F2018%2F12%2F25%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E5%85%AB)%20%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[收货地址接口设计 门户收货地址接口 链接 添加地址 控制器传入参数为HttpSession和Shipping对象，首先判断登录情况，如果未登录强制登录，否则将shipping参数和userId交给服务层处理； 传过来的shipping对象中userId正常情况下是空的，所以在服务层处理函数中，首先对shipping的userId项赋值，然后再将shipping插入到数据库中； 如果插入成功，则返回“新建地址成功”，并将插入后这条记录的shippingId返回 删除地址 控制器传入参数为HttpSession和shippingId，首先判断登录情况，如果未登录强制登录，否则将shippingId和userId交给服务层处理； 在服务层处理函数中，根据shippingId和userId把数据库中的对应项删除，然后返回“删除地址成功”或者“删除地址失败”； 1这里要注意横向越权，对于一个已登录用户，删除地址时不能仅通过shippingId，还同时要校验userId，否则会删除掉别人的地址记录 更新地址 控制器传入参数为HttpSession和Shipping对象（需要包含id项），首先判断登录情况，如果未登录强制登录，否则将shipping参数和userId交给服务层处理； 在服务层处理函数中，首先对shipping的userId项赋值，然后根据userId和shippingId在数据库中更新，最后返回“更新地址成功”或者“更新地址失败” 1传过来的userId可能会被模拟，造成横向越权，所以这里要重新赋值一下 mysql更新语句为： 12345678910111213141516&lt;update id="updateByShipping" parameterType="com.cr.mmall.pojo.Shipping"&gt; update mmall_shipping set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; and user_id = #&#123;userId,jdbcType=INTEGER&#125;&lt;/update&gt; 查询地址 控制器传入参数为HttpSession和shippingId，首先判断登录情况，如果未登录强制登录，否则将shippingId和userId交给服务层处理； 在服务层处理函数中，根据shippingId和userId查询数据库，如果查询成功则显示“查询地址成功”并将查到的shipping对象返回，否则返回“查询地址失败” 查询用户地址列表 控制器传入参数为HttpSession和分页参数（pageNum、pageSize，使用RequestParam设置默认值为1和10），首先判断登录情况，如果未登录强制登录，否则将分页参数和userId交给服务层处理； 在服务层处理函数中，根据userId查询数据库，得到地址列表，然后通过pageHelper的分页，将分页信息pageInfo返回即可，相关代码如下： 1234567@Overridepublic ServerResponse&lt;PageInfo&gt; list(Integer userId, int pageNum, int pageSize) &#123; PageHelper.startPage(pageNum, pageSize); List&lt;Shipping&gt; shippingList = shippingMapper.selectByUserId(userId); PageInfo pageInfo = new PageInfo(shippingList); return ServerResponse.createBySuccess(pageInfo);&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>pageHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（七） 购物车模块开发]]></title>
    <url>%2F2018%2F12%2F20%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E4%B8%83)%20%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[购物车接口设计 门户购物车接口 链接 查询购物车列表 控制层只需要HttpSession参数，获取登录信息，并得到userId供服务层处理 将查询的购物车列表封装成一个CartVo对象，包含了一个CartProductVo列表、购物车总价、是否全选、imageHost，其结构为： 123456public class CartVo &#123; private List&lt;CartProductVo&gt; cartProductVoList; private BigDecimal cartTotalPrice; private Boolean allChecked; private String imageHost;&#125; 其中CartProductVo也是一个Vo对象，表示购物车中某一种产品的详细信息，其结构为： 12345678910111213141516public class CartProductVo &#123; private Integer id; private Integer userId; private Integer productId; private Integer quantity; private String productName; private String productSubtitle; private String productMainImage; private BigDecimal productPrice; private Integer productStatus; private BigDecimal productTotalPrice; private Integer productStock; // 产品库存 private Integer productChecked; // 产品是否被勾选 private String limitQuantity; // 限制数量的返回结果&#125; 在服务层定义一个getCartVoLimit方法，参数为userId，返回值为CartVo对象。实现过程为：首先通过userId从数据库中查找属于该用户的cart列表，然后遍历列表，根据单个的cart中的产品Id查询对应的product，再结合cart和product中的信息，封装成CartProductVo，再将CartProductVo添加到cartProductVoList中； cartTotalPrice购物车总价的计算方式是已勾选产品的产品总价（单价*数量）之和，其中计算价格时使用BigDecimal避免精度丢失； 在计算产品总价时，需要先判断购物车中的数量是否大于产品库存数量，如果大于则更新数据库，将购物车中的数量设定为等于产品库存数量，如果小于则直接计算总价； allChecked是根据从数据库中查未checked的数量是不是0得到的；imageHost从属性文件中获得 经过以上步骤，可以通过一个userId得到一个CartVo，直接将CartVo作为ServerResponse的data返回即可 在测试发现，使用查询购物车列表时出现500错误，经过调试，发现是数据库中cart表的productId在product表中查不到，导致了后续的程序错误。解决方法是，在getCartVoLimit方法中，当查询productId时，如果查不到就将cartVo作为null返回；服务层处理函数中，再对cartVo进行判断，如果是null就返回参数错误 添加到购物车 控制器传入参数为产品Id和数量，首先判断登录情况，如果未登录强制登录，否则将参数交给服务层处理； 服务层首先校验参数的有效性，然后通过userId和productId从数据库中查询cart；如果cart未查到，则新建一个cart，设置userId、productId、count，设置勾选状态，然后插入到数据库中；否则在查到的cart的基础上更改count，再更新到数据库； 对数据库更新完成后，查询购物车列表，即根据userId获取cartVo，作为ServerResponse的data返回 更新购物车 控制器传入参数为产品Id和数量，首先判断登录情况，如果未登录强制登录，否则将参数交给服务层处理； 服务层首先校验参数的有效性，然后通过userId和productId从数据库中查询cart，在查到的cart的基础上更改count，再更新到数据库； 对数据库更新完成后，查询购物车列表，即根据userId获取cartVo，作为ServerResponse的data返回 删除购车产品 控制器传入参数为productId(productId是多个产品ID的字符串，由逗号隔开)，首先判断登录情况，如果未登录强制登录，否则将参数交给服务层处理； 服务层将productIds处理成productList，然后再结合userId，从数据库中删除对应的产品项，sql语句为： 12345678910&lt;delete id="deleteByUserIdProductIds" parameterType="map"&gt; delete from mmall_cart where user_id = #&#123;userId&#125; &lt;if test="productIdList != null"&gt; and product_id in &lt;foreach collection="productIdList" item="item" index="index" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/delete&gt; 对数据库更新完成后，查询购物车列表，即根据userId获取cartVo，作为ServerResponse的data返回 单选/取消单选 控制器传入参数为HttpSession和productId，首先判断登录情况，如果未登录强制登录，否则将参数交给服务层处理； 服务层处理函数的参数为userId、productId和勾选状态（单选checked=1，取消单选checked=0），根据这三个参数对数据库中属于该用户的某个产品项的勾选状态进行更改，其中sql语句为： 123456789&lt;update id="checkedOrUncheckedProduct" parameterType="map"&gt; UPDATE mmall_cart set checked = #&#123;checked&#125;, update_time = now() where user_id = #&#123;userId&#125; &lt;if test="productId != null"&gt; and product_id = #&#123;productId&#125; &lt;/if&gt;&lt;/update&gt; 最后查询购物车列表，将cartVo作为ServerResponse的data返回即可 全选/取消全选 控制器传入参数为HttpSession，首先判断登录情况，如果未登录强制登录，否则将参数交给服务层处理； 服务层处理函数的参数同上，因此对于productId参数，在控制器传入时设置为null，在mysql语句中已经对null情况作了判断 查询购物车产品总数 控制器传入参数为HttpSession，首先判断登录情况，如果未登录则返回0，否则将参数交给服务层处理； 服务层处理函数根据userId查询购物车中产品总数量，查询语句为： 123&lt;select id="selectCartProductCount" parameterType="int" resultType="int"&gt; select IFNULL(sum(quantity),0) as count from mmall_cart where user_id = #&#123;userId&#125;&lt;/select&gt; 值得注意的是，有可能根据userId查不到结果，为了避免出现null的情况，使用IFNULL()语句，设置默认返回值为0； 最后将查到的整形返回值作为ServerResponse的data返回]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解21-30]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A321-30%2F</url>
    <content type="text"><![CDATA[21 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路：要保持相对顺序不变，可以以空间换取时间，两次遍历，将奇数和偶数分别取出来再合并到一起 123456789101112131415161718192021222324252627282930313233343536373839/** * 21 调整数组顺序使奇数位于偶数前面 * 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分， * 并保证奇数和奇数，偶数和偶数之间的相对位置不变。 * * 解题思路：要保持相对顺序不变，可以以空间换取时间，两次遍历，将奇数和偶数分别取出来再合并到一起 */public class _21 &#123; public static void reOrderArray(int[] array) &#123; if (array == null || array.length == 0) &#123; return; &#125; int[] newArray = new int[array.length]; int index = 0; for (int item : array) &#123; if (item % 2 == 1) &#123; newArray[index++] = item; &#125; &#125; for (int item : array) &#123; if (item % 2 == 0) &#123; newArray[index++] = item; &#125; &#125; // 将原来栈区的元素改变(不能直接array=newArray，那样只是改变了形参的array指向，对主函数中的array不生效) for (int i = 0; i &lt; array.length; ++i) &#123; array[i] = newArray[i]; &#125; &#125; public static void main(String[] args) &#123; int[] array = &#123;1, 2, 3, 4, 5&#125;; reOrderArray(array); for (int i : array) &#123; System.out.print(i + " "); &#125; &#125;&#125; 22 链表中倒数第K个结点1234567891011121314151617181920212223242526272829303132333435363738394041/** * 22 链表中倒数第K个结点 * 输入一个链表，输出该链表中倒数第k个结点 * * 解题思路：使用两个指针，保持k-1的距离，同时向后遍历，后一个指针到达尾部时，前一个指针所指的节点即为所求 */public class _22 &#123; public ListNode FindKthToTail(ListNode head, int k) &#123; if (head == null || k &lt; 1) &#123; return null; &#125; ListNode node = head; int i = 0; while (head != null) &#123; head = head.next; if (i &gt;= k) &#123; node = node.next; &#125; ++i; &#125; if (i &lt; k) &#123; return null; &#125; return node; &#125; /** * 链表结构 */ public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 23 链表中环的入口结点 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路一： 定义两个指针，若环的长度为x，让一个指针先在起点，一个指针多走x步，然后两个指针一起前进，当相遇的时候，相遇点就是环的入口点； 环的长度获取可以通过快慢指针实现，快指针每次走两步，慢指针每次走一步，相遇时一定位于环上，然后从该点开始计数，直到回到该点时停止计数，得到的值就是环的长度； 解题思路二： 定义快慢指针，快指针每次走两步，慢指针每次走一步，在某个节点相遇，设链表起点到环的入口点距离为x，相遇点距环的入口点为y，环的长度为c，则有等式 2（x + y） = x + y + c 成立，得到x = c - y，说明：链表起点到环的入口点距离等于相遇点到环的入口点距离；因此，让两个指针分别从相遇点和链表起点出发（每次走一步），相遇点就是环的入口点 解题思路三： 断链法：每次访问一个节点后，将其前面的节点的next重置为null，这样当遇到一个节点的next为null时，说明该节点访问过，是环入口点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 23 链表中环的入口结点 * 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 * * 解题思路一： * 定义两个指针，若环的长度为x，让一个指针先在起点，一个指针多走x步，然后两个指针一起前进，当相遇的时候，相遇点就是环的入口点； * 环的长度获取可以通过快慢指针实现，快指针每次走两步，慢指针每次走一步，相遇时一定位于环上，然后从该点开始计数，直到回到该点时停止计数， * 得到的值就是环的长度； * * 解题思路二： * 定义快慢指针，快指针每次走两步，慢指针每次走一步，在某个节点相遇，设链表起点到环的入口点距离为x，相遇点距环的入口点为y，环的长度为c， * 则有等式 2（x + y） = x + y + c 成立，得到x = c - y，说明：链表起点到环的入口点距离等于相遇点到环的入口点距离；因此，让两个指针 * 分别从相遇点和链表起点出发（每次走一步），相遇点就是环的入口点 * * 解题思路三： * 断链法：每次访问一个节点后，将其前面的节点的next重置为null，这样当遇到一个节点的next为null时，说明该节点访问过，是环入口点 */public class _23 &#123; public static ListNode EntryNodeOfLoop(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; return null; &#125; ListNode slowNode = pHead.next; if (slowNode.next == null) &#123; return null; &#125; ListNode fastNode = slowNode.next; while (fastNode != slowNode) &#123; // 如果无环 if (fastNode == null || fastNode.next == null) &#123; return null; &#125; fastNode = fastNode.next.next; slowNode = slowNode.next; &#125; while (pHead != slowNode) &#123; pHead = pHead.next; slowNode = slowNode.next; &#125; return slowNode; &#125; public static void main(String[] args) &#123; ListNode listNode5 = new ListNode(5); ListNode listNode4 = new ListNode(4, listNode5); ListNode listNode3 = new ListNode(3, listNode4); ListNode listNode2 = new ListNode(2, listNode3); ListNode listNode1 = new ListNode(1, listNode2); listNode5.next = listNode3; System.out.println(EntryNodeOfLoop(listNode1).val); &#125; /** * 链表结构 */ public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125; 24 反转链表1234567891011121314151617181920212223242526272829303132333435/** * 24 反转链表 * 输入一个链表，反转链表后，输出新链表的表头。 */public class _24 &#123; public ListNode ReverseList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode curNode = head.next; head.next = null; while (curNode.next != null) &#123; ListNode tempNode = curNode.next; curNode.next = head; head = curNode; curNode = tempNode; &#125; // 将最后一个节点指向倒数第二个节点 curNode.next = head; return curNode; &#125; /** * 链表结构 */ public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 25 合并两个排序的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 25 合并两个排序的链表 * 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 * * 解题思路一： * 设置两个指针分别指向两个链表，每次比较当前两个指针所指向的值，哪个小就指向哪个，对应的指针后移，当其中一个链表遍历完后，直接指向另一个链表的当前指针 * * 解题思路二： * 递归法：比较最前面的节点值的大小，返回较小的作为头节点 */public class _25 &#123; public ListNode Merge(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; // 定义一个头指针 ListNode head = new ListNode(-1); ListNode cur = head; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt; list2.val) &#123; cur.next = list1; list1 = list1.next; &#125; else &#123; cur.next = list2; list2 = list2.next; &#125; cur = cur.next; &#125; if (list1 == null) &#123; cur.next = list2; &#125; else &#123; cur.next = list1; &#125; // 返回头指针指向的头节点 return head.next; &#125; /** * 递归法 * @param list1 链表1 * @param list2 链表2 * @return 合并后的头节点 */ public ListNode MergeRecursion(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; if (list1.val &lt; list2.val) &#123; list1.next = MergeRecursion(list1.next, list2); return list1; &#125; else &#123; list2.next = MergeRecursion(list1, list2.next); return list2; &#125; &#125; /** * 链表结构 */ public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 26 树的子结构12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 26 树的子结构 * 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） * * 解题思路：遍历树1所有节点，如果当前节点的值与树2的根节点值一样，就判断是否剩下结构相同（递归）,否则继续遍历 */public class _26 &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if (root1 == null || root2 == null) &#123; return false; &#125; return hasSubTreeCore(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2); &#125; private boolean hasSubTreeCore(TreeNode root1, TreeNode root2) &#123; if (root2 == null) &#123; return true; &#125; if (root1 == null) &#123; return false; &#125; if (root1.val != root2.val) &#123; return false; &#125; return hasSubTreeCore(root1.left, root2.left) &amp;&amp; hasSubTreeCore(root1.right, root2.right); &#125; /** * 二叉树结构 */ public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 27 二叉树的镜像12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 27 二叉树的镜像 * 操作给定的二叉树，将其变换为源二叉树的镜像。 * 二叉树的镜像定义：源二叉树 * 8 * / \ * 6 10 * / \ / \ * 5 7 9 11 * 镜像二叉树 * 8 * / \ * 10 6 * / \ / \ * 11 9 7 5 * * 解题思路：前序遍历的同时，交换左右子节点 */public class _27 &#123; public void Mirror(TreeNode root) &#123; if (root == null) &#123; return; &#125; // 交换左右节点 TreeNode node = root.left; root.left = root.right; root.right = node; // 继续遍历 Mirror(root.left); Mirror(root.right); &#125; /** * 二叉树结构 */ public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 28 对称的二叉树12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 28 对称的二叉树 * 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 * * 解题思路：同时进行前序遍历和对称前序遍历，判断遍历值是不是相同的，如果都相同说明对称 */public class _28 &#123; public boolean isSymmetrical(TreeNode pRoot) &#123; if (pRoot == null) &#123; return false; &#125; return isSymmetricalCore(pRoot, pRoot); &#125; private boolean isSymmetricalCore(TreeNode root1, TreeNode root2) &#123; // 两个节点可能都是null，此时也满足对称情况 if (root1 == null &amp;&amp; root2 == null) &#123; return true; &#125; // 两个节点的值有一个为null或者不相等，则不满足对称条件 if (root1 == null || root2 == null) &#123; return false; &#125; if (root1.val != root2.val) &#123; return false; &#125; return isSymmetricalCore(root1.left, root2.right) &amp;&amp; isSymmetricalCore(root1.right, root2.left); &#125; /** * 二叉树结构 */ public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;&#125; 29 顺时针打印矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.ArrayList;/** * 29 顺时针打印矩阵 * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4 * 矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. * * 解题思路： * 一圈一圈打印，从左往右，从上往下，从右往左，从下往上，每次打印一行或者一列后，对边界进行收缩， * 当边界不满足起始位置小于结束位置的条件时，结束循环即可 */public class _29 &#123; public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; int rowStart = 0; int rowEnd = matrix.length - 1; int colStart = 0; int colEnd = matrix[0].length - 1; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); while (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; // 从左到右 for (int i = colStart; i &lt;= colEnd; ++i) &#123; arrayList.add(matrix[rowStart][i]); &#125; rowStart++; // 从上到下 if (rowStart &gt; rowEnd) &#123; break; &#125; for (int i = rowStart; i &lt;= rowEnd; ++i) &#123; arrayList.add(matrix[i][colEnd]); &#125; colEnd--; // 从右到左 if (colEnd &lt; colStart) &#123; break; &#125; for (int i = colEnd; i &gt;= colStart; --i) &#123; arrayList.add(matrix[rowEnd][i]); &#125; rowEnd--; // 从下往上 if (rowEnd &lt; rowStart) &#123; break; &#125; for (int i = rowEnd; i &gt;= rowStart; --i) &#123; arrayList.add(matrix[i][colStart]); &#125; colStart++; &#125; return arrayList; &#125; public static void main(String[] args) &#123; int[][] matrix1 = &#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;, &#123;13, 14, 15, 16&#125;&#125;; int[][] matrix2 = &#123;&#123;1, 2, 3, 4, 5&#125;&#125;; int[][] matrix3 = &#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;, &#123;4&#125;, &#123;5&#125;&#125;; System.out.println(printMatrix(matrix1)); System.out.println(printMatrix(matrix2)); System.out.println(printMatrix(matrix3)); &#125;&#125; 30 包含min函数的栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Stack;/** * 30 包含min函数的栈 * 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 * * 解题思路： * 使用一个辅助堆栈，当push一个值时，与辅助栈栈顶元素比较，取较小的压入辅助栈；当pop一个值时，辅助栈也弹出一个值 */public class _30 &#123; private Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); public void push(int node) &#123; stack1.push(node); // 取较小的压入辅助栈 if (stack2.isEmpty()) &#123; stack2.push(node); &#125; else &#123; stack2.push(node &gt; stack2.peek() ? stack2.peek() : node); &#125; &#125; public void pop() &#123; stack1.pop(); stack2.pop(); &#125; public int top() &#123; return stack1.peek(); &#125; public int min() &#123; return stack2.peek(); &#125; public static void main(String[] args) &#123; _30 stack = new _30(); stack.push(3); System.out.println(stack.min()); stack.push(4); System.out.println(stack.min()); stack.push(2); System.out.println(stack.min()); stack.push(3); System.out.println(stack.min()); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（六） 商品管理模块开发]]></title>
    <url>%2F2018%2F12%2F10%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E5%85%AD)%20%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[POJO、BO、VO 产品接口设计 后台产品接口 链接 门户产品接口 链接 新增或更新产品 传入参数为Product对象，如果是新增产品，则Product实例中的Id应该为空，这样就调用mapper接口的insert方法，来更新产品信息；如果是更新产品信息，则Id应该不为空，调用mapper的updateByPrimaryKey方法来更新产品信息，其中主图来自于子图的第一个 控制器需要先验证用户是否登录并且具备管理员权限 产品上下架 传入参数为产品Id和状态status(表示在售、下架、删除) 控制器需要先验证用户是否登录并且具备管理员权限 服务层实现方法要先校验参数有效性，使用mapper接口的updateByPrimaryKeySelective来更新参数 产品详情 传入参数为产品Id，很据这个id返回产品详情，返回的产品详情相比于pojo中的product对象内容更加丰富，所以这里添加一个vo(value object)类，除了原来的product属性外，还添加了imageHost和parentCategoryId，同时创建时间和更新时间也需要转换成年月日的形式(joda) 控制器需要先验证用户是否登录并且具备管理员权限 服务层实现方法要先校验参数productId的有效性，然后检查这个id能否从数据库中查到product对象，如果查到了，将product装配到productDetailVo中，调用装配函数assembleProductDetailVo，参数为product，将productDetailVo作为data返回 assembleProductDetailVo返回值为ProductDetailVo，先装配product的各个属性，然后装配imageHost(ftp服务器url的前缀)，从属性文件中获取，再装配ParentId，根据当前产品的分类id来从数据库中查父节点分类ParentId，如果查不到当前分类，则将ParentId置为0 商品列表动态分页 传入参数为pageNum(默认=1)和pageSize(默认=10)，返回产品列表，这里添加一个ProductListVo，相比于product的pojo，省略了一些不必要的展示信息 控制器需要先验证用户是否登录并且具备管理员权限 服务层实现方法先配置pageHelper开始页，然后写sql查询产品列表，再遍历列表转化为ProductListVo的列表，最后pageHelper收尾，将pageResult的结果作为data返回 产品搜索 传入参数为产品名称、产品ID、pageNum(默认=1)、pageSize(默认=10)，搜索返回产品列表 与上一个功能类似，区别在于sql查询语句上，如果productName或者productId为空，就不作为查询条件，如果productName不为空，前后要加上sql的通配符“%”，这样可以实现模糊搜索 查询的SQL语句使用where标签和if标签，如下： 1234567891011SELECT &lt;include refid=&quot;Base_Column_List&quot;/&gt;from mmall_product&lt;where&gt; &lt;if test=&quot;productName != null&quot;&gt; and name like #&#123;productName&#125; &lt;/if&gt; &lt;if test=&quot;productId != null&quot;&gt; and id = #&#123;productId&#125; &lt;/if&gt;&lt;/where&gt; 文件上传(重要) 通过form表单，发起post请求，文件类型为multipart/form-data，匹配spring mvc的格式 12345&lt;h2&gt;Spring mvc 上传文件&lt;/h2&gt;&lt;form name="form1" action="/manage/product/upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="upload_file" /&gt; &lt;input type="submit" value="Spring mvc 上传文件" /&gt;&lt;/form&gt; 控制器返回的是一个map，包括了上传图片URL和URI。当图片上传到ftp服务器后，将图片的地址返回给前端，这样就可以把图片在网页上呈现出来，图片的命名通过随机的UUID生成，避免重复，返回的json格式为： 1234567&#123; "status": 0, "data": &#123; "uri": "e6604558-c0ff-41b9-b6e1-30787a1e3412.jpg", "url": "http://img.happymmall.com/e6604558-c0ff-41b9-b6e1-30787a1e3412.jpg" &#125;&#125; 控制器的传入参数为 1public ServerResponse upload(HttpSession session, @RequestParam(value = "upload_file", required = false) MultipartFile file, HttpServletRequest request) 首先需要根据session验证用户是否登录并且具备管理员权限，然后从request获取上传文件夹的路径path(/target/happymmall/upload)，然后调用服务层的实现方法上传文件，返回目标文件的名称(已经是UUID命名格式)，即uri，再拼接好ftp服务器的http前缀域名和文件名，组成url，然后封装到map中，作为data返回 服务层的实现方法是上传文件，参数为原始文件MultipartFile file和String path。根据file可以获得原始文件名，再通过分割得到文件扩展名，然后生成一个随机的uuid(避免重复)，拼接上扩展名，得到目标文件名。 接下来处理文件路径，根据传入的参数path和目标文件名，生成targetFile对象，然后通过file的transferTo方法(相当于将原始文件复制并重命名到上传文件夹，再调用FTPUtil的uploadFile方法上传文件，上传结束后将targetFile文件删除，否则上传文件夹会越变越大 接下来是FTPUtil的uploadFile方法，传入参数为targetFile(列表)。首先尝试连接和登录ftp服务器，需要host，port(默认21)，用户名和密码，ftp属性文件mmall.properties的配置内容为： 1234ftp.server.ip=127.0.0.1ftp.user=ftpuserftp.pass=ftpuserftp.server.http.prefix=http://image.imooc.com/ 然后配置ftp连接的相关属性，最重要的就是配置被动模式，否则会报SocketException: Connection reset或者FTPConnectionClosedException: Connection closed without indication异常，在这里困扰了很长时间，FTPClient类的说明文档)，最后参考自stackoverflow解决，FTP的几种连接模式简介PORT/PASV/EPRT/EPSV 123456789ftpClient.changeWorkingDirectory(remotePath);ftpClient.setBufferSize(1024);ftpClient.setControlEncoding("UTF-8");ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); /************************** 很重要 ***********************/ftpClient.enterLocalPassiveMode();ftpClient.setUseEPSVwithIPv4(true);/********************************************************/ 上传功能测试： 1、启动项目(运行tomcat) 2、启动IIS，并开启ftp站点，以便于java程序可以向ftp的/img路径下上传图片文件 3、启动Nginx，上传后的文件拼接了域名前缀，这样就可以通过返回的URL：http://image.imooc.com/xxx.png来直接访问到图片 4、先登录管理员账户，然后在首页选择一个图片上传，之后返回Map数据，包含了上传后图片的URL，点击可以打开，再访问ftp服务器，发现新增了一张图片，日志如下： 12345678910[com.cr.mmall.service.impl.FileServiceImpl] - 开始上传文件，上传文件的文件名:2d3fa4e3-87d0-41d7-bd5b-8135b13acbcf.png，上传的路径:E:\Java Projects\HappyMMall\happymmall\target\happymmall\upload，新文件名:0ee91666-8a46-4d4b-9e52-557a37f24b96.png[com.cr.mmall.service.impl.FileServiceImpl] - 文件开始上传[com.cr.mmall.util.FTPUtil] - 开始连接ftp服务器[com.cr.mmall.util.FTPUtil] - 尝试连接FTP服务器[com.cr.mmall.util.FTPUtil] - 连接FTP服务器状态：true[com.cr.mmall.util.FTPUtil] - 连接ftp服务器成功[com.cr.mmall.util.FTPUtil] - 结束上传，上传结果:true[com.cr.mmall.service.impl.FileServiceImpl] - 已经上传到ftp服务器上[com.cr.mmall.service.impl.FileServiceImpl] - 将目标文件删除[com.cr.mmall.service.impl.FileServiceImpl] - 目标文件名称：0ee91666-8a46-4d4b-9e52-557a37f24b96.png 富文本图片上传 总体上与文件上传类似，不同的是，富文本对返回值有要求，按照simditor的要求进行返回即可 12345&#123; "success": true/false, "msg": "error message", # optional "file_path": "[real file path]"&#125; 前台获取产品详情 与后台获取产品详情基本一致，不同之处在于，这里需要多判断一次，如果product的status表示下架或者删除状态，则返回错误消息“产品已下架或者删除”，并且不要判断管理员是否登录 前台产品搜索及排序 传入参数为产品关键词、分类ID、排序规则(价格升序、降序)，pageNum(默认=1)和pageSize(默认=10)，通过关键词或者分类来筛选产品，以产品分页列表的形式返回，与上面的商品列表动态分页类似 首先是对输入参数进行判断，如果keyword和categoryId都为空，则返回参数错误；如果categoryId不为空，但是查不到该分类的产品，且keyword为空，此时返回空结果集，不算是错误，new一个空的List，作为data返回即可；如果keyword不为空，则给它两端加上通配符“%”；如果categoryId不为空且可以查到该分类，则需要递归查询属于它的所有子分类，存储到一个list中categoryIdList 接下来是分页和排序处理，PageHelper.startPage(pageNum, pageSize)开始分页，使用PageHelper.orderBy()方法来设置排序规则，然后将非空的keyword和非空的categoryIdList作为参数，去数据库中查询符合要求的product列表，之后再将product列表转化为ProductListVo列表，最后pageHelper收尾，将pageInfo的结果作为data返回]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FTP</tag>
        <tag>MultipartFile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解11-20]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A311-20%2F</url>
    <content type="text"><![CDATA[11 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路：题目意思给定一个旋转的数组（部分有序），查找数组中最小值，可以采用二分查找，第一个指针始终指向前面递增数组的元素，第二个指针始终指向第二个递增数组的元素，最终两个指针相邻，此时第二个指针指向的元素是最小的元素，当两个指针指向的元素和中间位置的元素值都一样时，无法判断中间元素在第一个数组还是第二个数组中，采用顺序查找的方式 123456789101112131415161718192021222324252627282930313233343536public class _11 &#123; public static int minNumberInRotateArray(int [] array) &#123; if (array == null || array.length == 0) &#123; return 0; &#125; int low = 0; int high = array.length - 1; while (low &lt; high) &#123; int mid = (low + high) / 2; if (mid == low) &#123; return array[high]; &#125; // 顺序查找最小值 if (array[low] == array[mid] &amp;&amp; array[high] == array[mid]) &#123; int min = array[low]; for (int i = low + 1; i &lt;= high; ++i) &#123; if (min &gt; array[i]) &#123; min = array[i]; &#125; &#125; return min; &#125; if (array[low] &lt;= array[mid]) &#123; low = mid; &#125; else &#123; high = mid; &#125; &#125; return array[high]; &#125; public static void main(String[] args) &#123; int[] array = &#123;3, 4, 5, 1, 2&#125;; System.out.println(minNumberInRotateArray(array)); &#125;&#125; 12 矩阵中的路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 12 矩阵中的路径 * 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向 * 左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e * 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之 * 后，路径不能再次进入该格子 */public class _12 &#123; public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; // 标记矩阵中元素是否被访问过 boolean[][] visited = new boolean[rows][cols]; // 遍历矩阵找到与str[0]相同的元素，然后开始递归 for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols; ++j) &#123; if (hasPathCore(matrix, rows, cols, i, j, 0, visited, str)) &#123; return true; &#125; &#125; &#125; return false; &#125; private static boolean hasPathCore(char[] matrix, int rows, int cols, int i, int j, int k, boolean[][] visited, char[] str) &#123; // 将二维坐标转化为一维，注意这里是列*行坐标 + 列坐标 int index = cols * i + j; // 矩阵越界、对应位置已访问过、与目标元素不相等，则返回错误 if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || visited[i][j]) &#123; return false; &#125; // 目标路径的最后一个元素已经访问到，则返回正确 if (k == (str.length - 1)) &#123; return true; &#125; // 标记此位置已访问过 visited[i][j] = true; // 递归上下左右四种走法 if (hasPathCore(matrix, rows, cols, i + 1, j, k + 1, visited, str) || hasPathCore(matrix, rows, cols, i - 1, j, k + 1, visited, str) || hasPathCore(matrix, rows, cols, i, j + 1, k + 1, visited, str) || hasPathCore(matrix, rows, cols, i, j - 1, k + 1, visited, str)) &#123; return true; &#125; // 该位置不通，回溯 visited[i][j] = false; return false; &#125; public static void main(String[] args) &#123; char[] matrix = &#123;'a', 'b', 't', 'g', 'c', 'f', 'c', 's', 'j', 'd', 'e', 'h'&#125;; int rows = 3; int cols = 4; char[] str = &#123;'b', 'f', 'c', 'e'&#125;; System.out.println(hasPath(matrix, rows, cols, str)); &#125;&#125; 13 机器人的运动范围12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 13 机器人的运动范围 * 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标 * 的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3 * +8 = 19。请问该机器人能够达到多少个格子？ */public class _13 &#123; public static int movingCount(int threshold, int rows, int cols) &#123; if (threshold &lt; 0 || rows &lt; 0 || cols &lt; 0) &#123; return 0; &#125; boolean[][] visited = new boolean[rows][cols]; return movingCountCore(threshold, rows, cols, 0, 0, visited); &#125; /** * 核心递归函数 * @param threshold 门限 * @param rows 行数 * @param cols 列数 * @param i 当前所在行位置 * @param j 当前所在列位置 * @param visited 尝试访问标志 * @return count 返回可访问的方块数 */ private static int movingCountCore(int threshold, int rows, int cols, int i, int j, boolean[][] visited) &#123; // 矩阵越界、对应位置已尝试访问过，则返回false if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || visited[i][j]) &#123; return 0; &#125; // 标记当前位置已尝试访问 visited[i][j] = true; // 判断能否访问，如果可以则结果加1，继续访问下一个位置 if ((getSum(i) + getSum(j)) &lt;= threshold) &#123; return 1 + movingCountCore(threshold, rows, cols, i + 1, j, visited) + movingCountCore(threshold, rows, cols, i - 1, j, visited) + movingCountCore(threshold, rows, cols, i, j + 1, visited) + movingCountCore(threshold, rows, cols, i, j - 1, visited); &#125; // 拒绝访问当前位置，直接返回0 return 0; &#125; /** * 返回一个整数的各个数位的和 * @param number 参数为一个十进制整数 * @return 返回各数位之和 */ private static int getSum(int number) &#123; if (number &lt; 0) &#123; throw new RuntimeException("参数错误"); &#125; int sum = 0; while (number != 0) &#123; sum += number % 10; number /= 10; &#125; return sum; &#125; public static void main(String[] args) &#123; int threshold = 1; int rows = 2; int cols = 2; System.out.println(movingCount(threshold, rows, cols)); &#125;&#125; 14 剪绳子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 14 剪绳子 * 把一根绳子剪成多段，并且使得每段的长度乘积最大 * * 使用动态规划算法： * 第一种情况：题目规定至少剪一次绳子，每次剪绳子都是一分为二，若绳子长度为n，现在对于1到j的绳子段，在第i处剪，记f(j)是使得每段的长度 * 乘积最大的结果，则f(j)=max_i &#123;f(i) * f(j-i)&#125;，其中 1&lt;=j&lt;=n，1&lt;=i&lt;j，此时表明了在将绳子分成两段时，1到i段和i+1到j段又分别至少被 * 分割了一次； * 第二种情况：在将绳子分成两段时，就不再分割了，所以有f(j) = i * (j-i)； * 第三种情况：在将绳子分成两段时，一段分割，一段不分割，则有f(j) = f(i) * (j-i) 或 f(j) = i * f(j-i)； * 结论：f(j) = max_i &#123;f(i) * f(j-i), i * (j-i), f(i) * (j-i)&#125;，其中 1&lt;=j&lt;=n，1&lt;=i&lt;j * * 使用贪心算法： * n &gt;= 5时，尽可能剪长度为3的绳子，如果剩下的长度为4，则剪成2乘2的 */public class _14 &#123; public static int integerBreak(int n) &#123; int[] dp = new int[n + 1]; dp[1] = 1; for (int j = 2; j &lt;= n; ++j) &#123; for (int i = 1; i &lt; j; ++i) &#123; dp[j] = Math.max(dp[j], Math.max(i * (j - i), dp[i] * (j - i))); &#125; &#125; return dp[n]; &#125; public static int integerBreakGreed(int n) &#123; if (n &lt; 2) &#123; return 0; &#125; if (n == 2) &#123; return 1; &#125; if (n == 3) &#123; return 2; &#125; int timesOf3 = n / 3; if ((n - timesOf3 * 3) == 1) &#123; timesOf3--; &#125; int timesOf2 = (n - timesOf3 * 3) / 2; return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2)); &#125; public static void main(String[] args) &#123; System.out.println(integerBreak(8)); System.out.println(integerBreakGreed(8)); &#125;&#125; 15 二进制中 1 的个数12345678910111213141516171819202122/** * 15 二进制中 1 的个数 * 输入一个整数，输出该数二进制表示中 1 的个数 * * 可以通过将输入的整数每次算术右移，然后和1进行“与”运算；也可以令flag=1，每次与输入的数进行“与”运算，然后对flag左移； * 复杂度最低的做法是让输入的整数减一再与自身相与，会让整数最右边的1变为0 */public class _15 &#123; public static int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; count++; n &amp;= (n - 1); &#125; return count; &#125; public static void main(String[] args) &#123; System.out.println("NumberOf1 = " + NumberOf1(0b101010)); &#125;&#125; 16 数值的整数次方123456789101112131415161718192021222324252627282930313233/** * 16 数值的整数次方 * 给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方 * * 考虑底数为0，或者指数为0和负数的情况，乘方的计算可以通过递归以空间换取时间，注意指数是奇数还是偶数 */public class _16 &#123; public static double Power(double base, int exponent) &#123; boolean flag = false; if (base == 0) &#123; return 0; &#125; if (exponent == 0) &#123; return 1; &#125; // 指数为负数，取绝对值，最后返回倒数即可 if (exponent &lt; 0) &#123; flag = true; exponent = -exponent; &#125; double result = Power(base * base, exponent &gt;&gt; 1); // 如果指数是奇数，还需要多乘一次 if (exponent % 2 == 1) &#123; result *= base; &#125; return flag? 1 / result: result; &#125; public static void main(String[] args) &#123; System.out.println("Power(2, -3) = " + Power(2, -3)); System.out.println("Power(2, 3) = " + Power(2, 3)); &#125;&#125; 17 打印从1到最大的n位数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 17 打印从 1 到最大的 n 位数 * * 输入参数可能会很大，因此将题目转变成字符数组来打印，使用递归进行全排列 */public class _17 &#123; public static void print1ToMaxOfNDigits(int n) &#123; if (n &lt; 0) &#123; throw new RuntimeException("参数错误"); &#125; char[] number = new char[n]; print1ToMaxOfNDigitsCore(number, 0); &#125; /** * 核心全排列递归函数 * @param number 字符数组 * @param index 索引 */ private static void print1ToMaxOfNDigitsCore(char[] number, int index) &#123; // 当索引和数组长度相同时，说明数组已经完全被填充 if (index == number.length) &#123; printNumber(number); return; &#125; // 在每个索引的位置都有'0'到'9'，10种可能 for (int i = 0; i &lt; 10; ++i) &#123; number[index] = (char) ('0' + i); // 继续下一个索引位置的打印 print1ToMaxOfNDigitsCore(number, index + 1); &#125; &#125; /** * 打印时忽略字符数组中最前面的'0' * @param number 字符数组 */ private static void printNumber(char[] number) &#123; int startPrintIndex = 0; for (char cNumber : number) &#123; if (cNumber == '0') &#123; startPrintIndex++; &#125; else &#123; break; &#125; &#125; for (int i = startPrintIndex; i &lt; number.length; i++) &#123; System.out.print(number[i]); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; print1ToMaxOfNDigits(2); &#125;&#125; 18 删除链表中的节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 18 删除链表中的节点 * 题目一：在O(1)时间内删除链表节点 * 给定单链表的头指针和节点指针，在O(1)时间内删除该链表节点 * 分析：如果从头指针开始遍历，找到需要的删除的节点，复杂度为O(n)，不符合题意；可以将待删除节点的后一个节点的内容赋给当前节点，然后删除 * 当前节点的后一个节点，可以达到同样的效果，复杂度为O(1) * * 题目二：删除链表中重复的结点 * 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 * 处理后为 1-&gt;2-&gt;5 */public class _18 &#123; /** * 删除链表中的节点 * @param head 头指针 * @param toBeDeleted 待删除节点指针 * @return 返回删除节点后的链表的头指针 */ public ListNode deleteNode(ListNode head, ListNode toBeDeleted) &#123; if (head == null || toBeDeleted == null || head.next == null) &#123; return head; &#125; if (toBeDeleted.next == null) &#123; // 如果待删除节点是尾节点 ListNode node = head; while (node.next != toBeDeleted) &#123; node = node.next; &#125; node.next = null; toBeDeleted = null; &#125; else &#123; // 待删除节点不是尾节点 toBeDeleted.val = toBeDeleted.next.val; toBeDeleted.next = toBeDeleted.next.next; &#125; return head; &#125; /** * 删除链表中重复的结点(非递归方式) * @param pHead 头节点 * @return 返回删除节点后的链表的头指针 */ public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; return pHead; &#125; // 新建一个头指针 ListNode node = new ListNode(0); node.next = pHead; // 新建两个指针 ListNode preNode = node; ListNode curNode = pHead; while (curNode != null &amp;&amp; curNode.next != null) &#123; if (curNode.val != curNode.next.val) &#123; preNode = curNode; curNode = curNode.next; &#125; else &#123; while (curNode.next != null &amp;&amp; curNode.val == curNode.next.val) &#123; curNode = curNode.next; &#125; curNode = curNode.next; preNode.next = curNode; &#125; &#125; return node.next; &#125; /** * 删除链表中重复的结点(递归方式) * @param pHead 头节点 * @return 返回删除节点后的链表的头指针 */ public ListNode deleteDuplicationRecursion(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; return pHead; &#125; ListNode nextNode = pHead.next; // 如果头节点是重复节点 if (pHead.val == nextNode.val) &#123; while ((nextNode != null) &amp;&amp; (nextNode.val == pHead.val)) &#123; nextNode = nextNode.next; &#125; return deleteDuplicationRecursion(nextNode); &#125; else &#123; pHead.next = deleteDuplicationRecursion(pHead.next); return pHead; &#125; &#125; /** * 链表结构 */ public class ListNode &#123; int val; ListNode next = null; ListNode(int value) &#123; this.val = value; &#125; &#125;&#125; 19 正则表达式匹配123456789101112131415161718192021222324252627282930313233343536/** * 19 正则表达式匹配 * 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 * 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配 */public class _19 &#123; public static boolean match(char[] str, char[] pattern) &#123; boolean[][] dp = new boolean[str.length + 1][pattern.length + 1]; dp[0][0] = true; for (int i = 1; i &lt; dp[0].length; i ++) &#123; if(pattern[i - 1] == '*') &#123; dp[0][i] = dp[0][i - 2]; &#125; &#125; for (int i = 1; i &lt; dp.length; i ++) &#123; for (int j = 1; j &lt; dp[0].length; j ++) &#123; if (pattern[j - 1] == '.' || pattern[j - 1] == str[i - 1]) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if (pattern[j - 1] == '*') &#123; if (pattern[j - 2] != str[i - 1] &amp;&amp; pattern[j - 2] != '.') &#123; dp[i][j] = dp[i][j - 2]; &#125; else &#123; dp[i][j] = dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j]; &#125; &#125; &#125; &#125; return dp[str.length][pattern.length]; &#125; public static void main(String[] args) &#123; char[] str = &#123;'a', 'c'&#125;; char[] pattern = &#123;'.', '*'&#125;; System.out.println(match(str, pattern)); &#125;&#125; 20 表示数值的字符串1234567891011121314/** * 20 表示数值的字符串 * 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 * 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是 */public class _20 &#123; public boolean isNumeric(char[] str) &#123; if (str == null || str.length == 0) &#123; return false; &#125; return String.valueOf(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（五） 分类管理模块开发]]></title>
    <url>%2F2018%2F11%2F30%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E4%BA%94)%20%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[分类接口设计 后台分类接口 链接 添加品类 根据传入的品类名称和父节点ID类添加品类 控制器中首先检查管理员是否登录，如果登录调用服务层以下的方法 首先需要检查传入参数的有效性，如果为空则返回参数错误，之后new一个Category对象，设置品类名称、父节点ID和状态，然后调用categoryMapper的insert方法，插入category到数据库 更改品类名称 传入参数为品类ID和品类名，将根据这个ID来修改品类名 控制器中首先检查管理员是否登录，如果登录调用服务层以下的方法 首先需要检查传入参数的有效性，如果为空则返回参数错误，之后new一个Category对象，设置品类名称、品类ID，然后调用categoryMapper的updateByPrimaryKeySelective方法，更新品类名到数据库 查询次级子节点品类 传入参数为品类ID，将根据这个ID来查询其所有的次级子节点品类，返回值类型为ServerResponse &lt;List &gt; (在正确查询的情况下，否则返回错误消息) 控制器中首先检查管理员是否登录，如果登录调用服务层getChildrenParallelCategory方法 首先需要检查传入参数的有效性，如果为空则返回参数错误，然后调用categoryMapper的selectCategoryChildrenByParentId方法，将查到的List 作为data返回 查询当前节点和所有子节点 传入参数为品类ID，将根据这个ID来查询当前节点和所有子节点的ID值，放到list中，作为data返回 控制器中首先检查管理员是否登录，如果登录调用服务层的selectCategoryAndChildrenById方法 服务层的findChildCategory方法，参数为set(去重，使用set要重写category pojo的hashcode和equal方法，以id为判断准则)，每次根据id来从数据库查找category对象，如果存在则加入到set中，然后查找数据库中所有以当前节点为父节点的子节点，存储到list中，然后遍历子节点，循环调用findChildCategory方法，如果当前节点没有子节点了，那么遍历的过程也不会进入，最后返回set，即查到了所有的子节点和当前节点，代码如下： 123456789101112131415// 递归算法，算出左右的子节点 private Set&lt;Category&gt; findChildCategory(Set&lt;Category&gt; categorySet, Integer categoryId) &#123; // 查找当前节点，加入到Set中 Category category = categoryMapper.selectByPrimaryKey(categoryId); if (category != null) &#123; categorySet.add(category); &#125; // 查找次级所有子节点 List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParentId(categoryId); // 如果查不到子节点，则不会执行以下循环；如果查到了，则遍历子节点，递归 for (Category categoryItem : categoryList) &#123; findChildCategory(categorySet, categoryItem.getId()); &#125; return categorySet; &#125; 服务层的selectCategoryAndChildrenById方法，先初始化一个空set，然后根据传入的categoryId，调用findChildCategory方法，之后再把set中所有的category的id提取到一个list中，作为ServerResponse的data返回，代码如下; 12345678910111213public ServerResponse selectCategoryAndChildrenById(Integer categoryId) &#123; Set&lt;Category&gt; categorySet = Sets.newHashSet(); findChildCategory(categorySet, categoryId); // 将set转为list返回 List&lt;Integer&gt; categoryIdList = Lists.newArrayList(); if (categoryId != null) &#123; for (Category categoryItem : categorySet) &#123; categoryIdList.add(categoryItem.getId()); &#125; &#125; return ServerResponse.createBySuccess(categoryIdList); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（四） 用户模块开发]]></title>
    <url>%2F2018%2F11%2F25%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%20%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[横向越权与纵向越权 横向越权：攻击者尝试访问与他拥有相同权限的用户的资源，比如A用户尝试查询B用户的订单号 纵向越权：低级别攻击者尝试访问高级别用户的资源，比如普通用户通过分析接口尝试上升到管理员级别 MD5加盐值salt MD5存在一些字典，如果是单纯的MD5加密，则可能通过字典将密码破解出来 盐值salt可以是自定义的一个字符串，当获取用户密码后，拼接上这个字符串，再进行MD5加密，这样就增加了破解难度 用户接口设计 门户用户接口设计 链接 后台用户接口设计 链接 登录功能 在common包下创建三个类，Const，ResponseCode，ServerResponse，ResponseCode是一个枚举类，包含了不同的状态信息和状态码；ServerResponse实现了序列化接口，包含了三个字段，分别是状态码，状态信息，和泛型的数据，通过不同的静态方法create*方法就可以给这三个字段赋值，并返回新的ServerResponse对象 服务层UserServiceImpl中注入UserMapper方法，有一个login登录方法，参数为用户名和密码，返回的是ServerResponse 类型。login方法中通过UserMapper接口检查数据库，判断用户名是否错误，密码是否错误，如果都正确，从数据库中查询到对应的User对象返回到ServerResponse的data字段中，状态消息msg为“登录成功“，状态码status为0 控制层的UserController类中注入了服务层的IUserService，含有login方法，uri对应为/login/login，限定post方法，返回值为ServerResponse，使用@ResponseBody注解实现将Controller类方法返回对象转换为json响应给客户端(在springmvc-servlet.xml已经配置了HttpMessageConverter和JSON消息转换器)。根据前端传来的username和password方法，调用IUserService的login方法，获得ServerResponse 实例，通过isSuccess方法(状态码是否为0)判断是否登录成功，如果是则通过getData()方法将data(即User讯息)传给httpsession 登出功能 在UserController类中添加logout方法，对应的uri为/login/logout，从session中移除刚刚登录时传入的User信息即可 注册功能 在Util包下添加MD5Util工具类，用于密码的MD5加密，这样存入数据库的密码不会明文显示 服务层UserServiceImpl类中添加register方法，参数为User，返回类型ServerResponse 。首先检查用户名和Email是否重复，如果核验通过则设置User的Role属性为普通用户，并将密码MD5加密，然后调用UserMapper接口的insert方法插入用户信息到数据库中 校验功能 便于用户在注册时实时检查用户名和邮件是否有效 服务层UserServiceImpl类中添加checkValid方法，参数为String型的str和type，如果type是“username”，则将str作为username在数据库中查找是否重复；如果type是“email”，则将str作为email在数据库中查找是否重复 控制器UserController类中添加checkValid方法，uri为/login/check_valid 获取用户登录信息 控制器UserController类中添加getUserInfo方法，通过session.getAttribute中获取User信息 忘记密码1、找到密保问题 服务层UserServiceImpl类中添加selectQuestion方法，校验用户名是否存在，如果有则查询数据库中的密码提示问题，将问题作为data返回即可 控制器UserController中调用服务层的selectQuestion方法 2、检验密保问题是否正确 common包下添加TokenCache类，可以调用其setKey方法将key：token_username和value：randomUUID放入本地缓存中也可以通过getKey方法查询value值 服务层UserServiceImpl类中添加checkAnswer方法，验证用户名-问题-答案在数据库中是否匹配，如果是，则生成一个随机的uuid，与token_username形成键值对，加入到本地缓存中，并将token(uuid)作为data返回；如果否则显示密码错误 控制器UserController中调用服务层的checkAnswer方法，将token返回到前端，修改密码的时候需要用这个 3、重置新密码 服务层UserServiceImpl类中添加resetPassword方法，传入的参数为用户名、新密码、forgetToken，首先检查传入的forgetToken是否为空白，然后检查用户名有效性，再根据用户名查询本地缓存中的token，再比较本地的token和传入的forgetToken是否一致，如果是则更新密码，把新密码MD5加密后更新到数据库中 控制器UserController中调用服务层的forgetResetPassword方法返回即可 登录状态1、登录状态下重置密码 服务层UserServiceImpl类中添加resetPassword方法，传入的参数为旧密码、新密码、用户。首先是验证旧密码是否正确，注意这里要防止横向越权，校验用户旧密码的同时，一定要同时校验用户名，否则容易被人用密码字典撞库，如果查不到则返回错误消息，否则下一步将新密码MD5加密更新到User中，再更新到数据库中 控制器UserController中添加resetPassword方法，参数为旧密码、新密码和HttpSession，先从session中获取当前用户信息，如用户存在则调用上面的UserServiceImpl的resetPassword方法，否则返回“用户未登录”消息 2、更新个人信息 服务层UserServiceImpl类中添加updateInformation方法，传入的参数为User，其中username和userId被设置为当前登录用户的信息(username和userId是不可被修改部分，其他信息就来自于用户修改的信息，从前端传过来，此部分操作在控制器中执行)。然后首先要校验下email是否有效，如果email和当前登录用户的email不一致，则不能与数据库中其他用户的email重复。如果校验成功就可以new一个User实例updateUser，将可更新的内容赋给updateUser，然后调用userMapper的updateByPrimaryKeySelective方法，对非null的项，根据userId更新到数据库中。如果更新成功，则显示更新成功消息，并且把更新后的updateUser保存到data中，以便于在控制器中可以更新session参数 控制器UserController中添加updateInformation方法，参数为HTTPSession和User，先检查用户是否登录，即session中是否有user信息。如果是，则把当前登录用户的用户名和ID赋给传进来的user，之后在调用服务层UserServiceImpl类中的updateInformation方法，如果更新成功，则将更新的用户对象存在session中，否则直接返回即可 3、根据用户ID获取登录用户信息 如果未登录，则返回status=10，前端可以强制跳转到登录界面 服务层通过userId从数据库查询用户信息 控制器中先判断用户是否登录，如果是则从session中获取User对象，再通过userId调用服务层方法查询数据库，得到的User信息返回给前端 后台管理员登录 controller/backend包下添加UserManagerController类，注入服务层实现类iUserService，添加login方法 在login方法中，首先调用iUserService的login方法，判断是否登录成功，如果成功，则根据role判定是否为管理员]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（三） 项目初始化]]></title>
    <url>%2F2018%2F11%2F20%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E4%B8%89)%20%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库建立 安装并打开Navicat for MySQL，新建一个数据库happymmall，字符集UTF-8，默认collation: UTF-8_Bin 新建一个查询Queries，在查询编辑器中黏贴mmall.sql的内容，然后运行Run即可 实际项目中，应当自行构建数据表结构 IDEA安装 官网下载专业版，可用学生邮箱激活 Jdk配置 选择安装的jdk 1.8版本 Maven配置 官网下载，解压缩，IDEA中设置Maven的文件夹路径，并修改settings.xml中的相关设置，修改为阿里云镜像源，修改仓库地址 Tomcat配置 创建Maven Archetype Webapp项目后，设置好java源文件夹，resources资源文件夹、Test文件夹等，然后添加Tomact Server，选择解压的tomcat文件夹路径，再配置Deployment。 初始化Git仓库 在Github上新建仓库happymmall，然后clone到本地的工程文件夹HappyMMall 12git clone git@github.com:wychencr/happymmall.gitcd happymmall 添加.gitignore文件 12345678910111213141516171819202122232425262728293031323334*.class# package file*.war*.ear# kdiff3 ignore*.org# maven ignoretarget/# eclipse ignore.settings/.project.classpatch# idea.idea//idea/*.ipr*.iml*.iws# temp file*.log*.cache*.diff*.patch*.tmp# system ignore.DS_StoreThumbs.db 再添加项目文件、readme.md等，commit后push到远程仓库中 123git add -Agit commit -m &quot;add some files&quot;git push 分支开发，主干发布 123456789# 查看本地和远程分支git branchgit branch -r# 新建一个分支，并切换到该分支git checkout -b v1.0 origin/master# 推送到远程分支git push origin HEAD -u 配置pom.xml 存在几个jar包不能导入的情况，此时适当降低版本号，可以解决，比如mybatis的分页插件，改为4.1.0版本后可正常使用 项目包结构初始化 在WEB-INF下需要额外建立一个lib文件夹，存放支付宝的SDK包 在SSM工程的基础上，要修改好tomcat和module配置 logback日志配置 ftp服务器属性配置 修改IDEA设置，spring core code autowriting for bean class 为 warning chrome插件安装 WEB前端助手(FeHelper) 1包括JSON格式化、二维码生成与解码、信息编解码、代码压缩、美化、页面取色、Markdown与HTML互转、网页滚动截屏、正则表达式、时间转换工具、编码规范检测、页面性能检测、Ajax接口调试、密码生成器、JSON比对工具、网页编码设置 Restlet Client 1Visually create and run single HTTP requests]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（二） 数据表结构设计]]></title>
    <url>%2F2018%2F11%2F15%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[数据表结构用户表 表示注册用户的信息，用户名、密码、密保等。 用户名建立唯一索引。 分类表 表示分类信息，id对应的是当前分类，是parent_id所对应的分类的子分类。 产品表 表示商品信息，包括名称、价格、详情介绍等。 decimal(20， 2)表示18个整数位，两个小数位。 购物车表 支付信息表 订单表 订单明细表 可以使用用户id和订单号组合索引。 收货地址表 数据表关系 用户注册后，信息填入user表中，登陆是读取user表 搜索产品时需要分类表和产品表，对于传入的分类id，进行分类表递归，找到所有符合分类的产品 选定产品加入购物车时，将user_id、product_id等信息放到购物车表 提交的订单后，需要填写购物地址等信息，存在收货地址表 然后生成订单号，对订单表进行处理，支付信息根据购物车表来计算 最后根据支付信息表的状态，修改订单表的状态 索引与时间戳 唯一索引可以避免信息提交重复，并且加快搜索时间 时间戳包括了创建时间和更新时间两个字段]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解02-10]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A302-10%2F</url>
    <content type="text"><![CDATA[02 单例模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 从具体实现角度来说，主要有三点：一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 懒汉式-线程不安全public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125;// 双重校验锁-线程安全public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125;// 静态内部类实现public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 03 数组中重复的数字12345678910111213141516171819202122232425/** * 03 数组中重复的数字 * 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道 有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 */public class _03 &#123; public static boolean duplicate(int[] numbers,int length,int[] duplication) &#123; int [] array = new int[length]; for (int i = 0; i &lt; length; ++i) &#123; if (array[numbers[i]] == 0) &#123; array[numbers[i]] = 1; &#125; else &#123; duplication[0] =numbers[i]; return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int[] numbers = &#123;2, 3, 1, 0, 2, 5, 3&#125;; int[] duplication = new int[1]; System.out.println(duplicate(numbers, numbers.length, duplication) + " " + duplication[0]); &#125;&#125; 04 二维数组中的查找12345678910111213141516171819202122232425262728293031323334/** * 04 二维数组中的查找 * 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 */public class _04 &#123; public static boolean find(int target, int [][] array) &#123; if (array == null || array.length == 0) &#123; return false; &#125; if (array[0].length == 0) &#123; return false; &#125; int col = array[0].length; int row = array.length; int i = row - 1; int j = 0; while (j &lt; col &amp;&amp; i &gt;= 0) &#123; if (array[i][j] == target) &#123; return true; &#125; else if (array[i][j] &gt; target) &#123; i--; &#125; else &#123; j++; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int[][] array = &#123;&#123;1, 4, 7, 11, 15&#125;, &#123;2, 5, 8, 12, 19&#125;&#125;; System.out.println("Find(5, array) = " + find(5, array)); &#125;&#125; 05 替换空格123456789101112131415161718192021222324252627282930313233343536/** * 05 替换空格 * 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过 替换之后的字符串为We%20Are%20Happy。 * * 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符 （%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。 * 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。 * 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容 */public class _05 &#123; public static String replaceSpace(StringBuffer str) &#123; int originalLength = str.length(); for (int i = 0; i &lt; originalLength; ++i) &#123; if (str.charAt(i) == ' ') &#123; // 每遇到一个空格扩充2个长度 str.append(" "); &#125; &#125; int newLength = str.length(); int j = newLength - 1; for (int i = originalLength - 1; i &gt;= 0; --i) &#123; if (str.charAt(i) == ' ') &#123; str.setCharAt(j--, '0'); str.setCharAt(j--, '2'); str.setCharAt(j--, '%'); &#125; else &#123; str.setCharAt(j--, str.charAt(i)); &#125; &#125; return str.toString(); &#125; public static void main(String[] args) &#123; replaceSpace(new StringBuffer("We Are Happy")); &#125;&#125; 06 从头到尾打印链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.ArrayList;import java.util.List;import java.util.Stack;/** * 06 从头到尾打印链表 * 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 *//** * public class ListNode &#123; * int val; * ListNode next = null; * * ListNode(int val) &#123; * this.val = val; * &#125; * &#125; * */public class _06 &#123; /** * 使用堆栈 * @param listNode 链表头结点 * @return 反向打印所有值 */ public static ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode == null) &#123; return new ArrayList&lt;&gt;(); &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; while (!stack.empty()) &#123; arrayList.add(stack.pop()); &#125; return arrayList; &#125; /** * 使用递归 * @param listNode 链表头结点 * @return 反向打印所有值 */ public static ArrayList&lt;Integer&gt; printListFromTailToHead1(ListNode listNode) &#123; if (listNode == null) &#123; return new ArrayList&lt;&gt;(); &#125; ArrayList&lt;Integer&gt; arrayList = printListFromTailToHead1(listNode.next); arrayList.add(listNode.val); return arrayList; &#125; /** * 使用头插法 * 构建一个头指针head，初始head-&gt;next = null，然后不断将listNode中的节点加到head后 面，相当于反向链表 * @param listNode 链表头结点 * @return 反向打印所有值 */ public static ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) &#123; if (listNode == null) &#123; return new ArrayList&lt;&gt;(); &#125; // 头指针 ListNode head = new ListNode(0); head.next = null; // 将listNode中的结点逐步加到head后面 while (listNode != null) &#123; // 先存储下一个结点 ListNode nextNode = listNode.next; // 头插 listNode.next = head.next; head.next = listNode; // 继续下一次循环 listNode = nextNode; &#125; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); // 头结点 listNode = head.next; while (listNode != null) &#123; arrayList.add(listNode.val); listNode = listNode.next; &#125; return arrayList; &#125; public static void main(String[] args) &#123; // 构造一个链表 ListNode listNode1 = new ListNode(1); ListNode listNode2 = new ListNode(2); listNode2.next = null; listNode1.next = listNode2; List&lt;Integer&gt; list = printListFromTailToHead2(listNode1); for (Integer integer : list) &#123; System.out.println(integer + " "); &#125; &#125; /** * 内部类：相当于一个链表节点 */ public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 07 重建二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 07 重建二叉树 * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结 果中都不含重复的数字。例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。 * 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序 遍历结果，右部分为树的右子树中序遍历的结果,然后就可以接着分别对左右子树递归下去。 *//** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class _07 &#123; /** * 重建二叉树 * @param pre 前序遍历 * @param in 中序遍历 * @return 返回重建的二叉树 */ public static TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if (pre == null || in == null || pre.length == 0 || in.length == 0) &#123; return null; &#125; return reConstructBinaryTree(pre, in, 0, pre.length - 1, 0, in.length - 1); &#125; /** * 扩充前序与中序的索引参数，便于递归重建二叉树 * @param pre 前序遍历 * @param in 中序遍历 * @param preStart 前序遍历数组的开始索引 * @param preEnd 前序遍历数组的结束索引 * @param inStart 中序遍历数组的开始索引 * @param inEnd 中序遍历数组的结束索引 * @return 返回重建的二叉树 */ private static TreeNode reConstructBinaryTree(int [] pre,int [] in, int preStart, int preEnd, int inStart, int inEnd) &#123; if (preStart &gt; preEnd) &#123; return null; &#125; // 根节点的值是前序遍历的第一个值 int rootValue = pre[preStart]; TreeNode treeNode = new TreeNode(rootValue); // 找到中序遍历序列中的根节点的位置，递归得到左右节点 for (int i = inStart; i &lt;= inEnd; ++i) &#123; if (in[i] == pre[preStart]) &#123; treeNode.left = reConstructBinaryTree(pre, in, preStart + 1, preStart + i - inStart, inStart, i - 1); treeNode.right = reConstructBinaryTree(pre, in, preStart + i - inStart + 1, preEnd, i + 1, inEnd); break; &#125; &#125; return treeNode; &#125; public static void main(String[] args) &#123; int[] pre = &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; int[] in = &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; reConstructBinaryTree(pre, in); &#125; /** * 内部类：二叉树结构 */ public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;&#125; 08 二叉树的下一个结点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 08 二叉树的下一个结点 * 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不 仅包含左右子结点，同时包含指向父结点的指针 * 分三种情况： * （1）当前节点有右子树，则下一个中序遍历节点是右子树中的最左节点 * （2）当前节点没有右子树，且该节点是其父节点的左节点，则下一个节点是其父节点 * （3）当前节点没有右子树，且该节点是其父节点的右节点，则沿着其父节点向上遍历，直到找到一个 是其父节点的左节点的节点，这个节点的父节点即为所求 *//** public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125; &#125;*/public class _08 &#123; public static TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) &#123; return null; &#125; // 当前节点有右子树 if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; // 当前节点没有右子树，且该节点没有父节点，是根节点 if (pNode.next == null) &#123; return null; &#125; // 当前节点没有右子树，且该节点是其父节点的左节点 if (pNode.next.left == pNode) &#123; return pNode.next; &#125; // 当前节点没有右子树，且该节点是其父节点的右节点 if (pNode.next.right == pNode) &#123; pNode = pNode.next; while (pNode.next != null) &#123; if (pNode.next.left != pNode) &#123; pNode = pNode.next; &#125; else &#123; return pNode.next; &#125; &#125; &#125; return null; &#125; /** * 二叉树结构，包含了指向其父节点的指针 */ public static class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125; &#125;&#125; 09 用两个栈实现队列12345678910111213141516171819202122232425262728293031323334353637import java.util.Stack;/** * 09 用两个栈实现队列 * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型 * 栈1的push对应队列的deleteHead操作，栈2的pop操作对应队列的insertTail操作，当栈2为空时， 将栈1的元素依次出栈，进到栈2中，如果栈1也为空，则提示队列为空 */public class _09 &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); /** * 队列的insertTail操作 * @param node 插入队尾的元素 */ public void push(int node) &#123; stack1.push(node); &#125; /** * 队列的deleteHead操作 * @return 删除队列头部 */ public int pop() &#123; if (stack2.empty()) &#123; if (stack1.empty()) &#123; throw new RuntimeException("队列为空"); &#125; else &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; &#125; return stack2.pop(); &#125;&#125; 10 斐波那契数列1234567891011121314151617181920212223242526/** * 10 斐波那契数列 * 大家都知道斐波那契数列，后一项等于前两项和，现在要求输入一个整数n，请你输出斐波那契数列的 第n项（从0开始，第0项为0，n&lt;=39）。 * 使用两个数将结果前两项缓存即可 */public class _10 &#123; public static int Fibonacci(int n) &#123; int result = 0; int temp1 = 0; int temp2 = 1; if (n == 1) &#123; return temp2; &#125; for (int i = 1; i &lt; n; i++) &#123; result = temp1 + temp2; temp1 = temp2; temp2 = result; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println("Fibonacci(3) = " + Fibonacci(3)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java电商项目学习（一） 环境配置]]></title>
    <url>%2F2018%2F11%2F10%2FJava%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0(%E4%B8%80)%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Jdk安装Maven安装Tomcat安装Ftp服务器配置 下载绿色版ftpserver，链接，解压 双击FTPServer.exe，即可以配置用户名、密码、文件操作权限、文件目录等 点击启动按钮，浏览器访问ftp://localhost/，即可登录 如果上面的ftp服务器不能使用，可以使用Windows自带的IIS，使用windows自带的IIS添加FTP的方法 链接，IIS默认启动后会与nginx冲突，所以要修改默认页的端口，nginx设定的监听端口是80，所以可以将IIS默认页的端口设定为如8086，tomcat的默认端口是8080，这样就不冲突了 后面在使用org.apache.commons.net.ftp.FTPClient登录ftp服务器时，发现匿名身份不能连接成功，所以需要设置ftp登录的账户和密码。在IIS管理器的FTP身份验证设置中，禁用匿名身份验证，启用基本身份验证，然后在计算管理中，新建一个测试账户，比如用户名和密码都为ftpuser，如下图 Nginx安装1Nginx是一款轻量级Web服务器，也是一款反向代理服务器。 下载Nginx，http://learning.happymmall.com/nginx/，解压到D盘 进入cmd，找到nginx.exe所在目录，命令行输入 1D:\windows-nginx-1.10.2\nginx-1.10.2 &gt; nginx.exe 这样就启动了Nginx，在任务管理器的进程中也可以看到 进入C:\Windows\System32\drivers\etc，找到hosts文件，增加一行： 1127.0.0.1 www.imooc.com 然后浏览器输入www.imooc.com或者localhost，可以看到Nginx的欢迎页面 下载http://learning.happymmall.com/nginx/windows_conf/下的**nginx.conf**主配置文件，覆盖放到Nginx安装目录/cong/下 在/cong目录下新建vhost文件夹，下载http://learning.happymmall.com/nginx/windows_conf/vhost/下的`image.imooc.com.conf` 和 tomcat.imooc.com.conf ，放置到本地vhost文件夹下 在F盘建立文件夹F:\ftpfile\img，并添加一个图片，例如1.png 然后修改image.imooc.com.conf： 1234567891011121314151617181920server &#123; listen 80; autoindex off; server_name image.imooc.com; access_log f:/access.log combined; index index.html index.htm index.jsp index.php; #error_page 404 /404.html; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; location ~ /(mmall_fe|mmall_admin_fe)/dist/view/* &#123; deny all; &#125; location / &#123; root F:\ftpfile\img; add_header Access-Control-Allow-Origin *; &#125;&#125; 这样浏览器访问image.imooc.com/*就可以重定向到F:\ftpfile\img文件目录下的文件了。 需要注意的的，这里的配置项autoindex off，如果关闭，浏览器访问image.imooc.com就会显示403无权限，这样更安全。如果开启，文件夹下的所有文件就会暴露出来。 修改tomcat.imooc.com.conf 123456789101112131415server &#123; listen 80; autoindex on; server_name tomcat.imooc.com; access_log f:/access.log combined; index index.html index.htm index.jsp index.php; #error_page 404 /404.html; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; location / &#123; proxy_pass http://127.0.0.1:8080; add_header Access-Control-Allow-Origin *; &#125;&#125; 这样当浏览器访问tomcat.imooc.com时，就可以被重定向到http://127.0.0.1:8080，即Tomcat的主页。 修改hosts文件最后一行： 123# 127.0.0.1 www.imooc.com 修改这行127.0.0.1 image.imooc.com127.0.0.1 tomcat.imooc.com 进入cmd界面，输入指令 12&gt; nginx.exe -t&gt; nginx.exe -s reload 浏览器进入http://image.imooc.com/1.png，可以显示图片；启动tomcat安装目录/bin下的**startup.bat**，启动tomcat服务器，然后浏览器进入http://tomcat.imooc.com/，就可以重定向到tomcat主页，说明配置完成。 MySQL安装Git安装]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tomcat</tag>
        <tag>Nginx</tag>
        <tag>FTP</tag>
        <tag>Maven</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA整合SSM框架]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BD%BF%E7%94%A8IDEA%E6%95%B4%E5%90%88SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、安装环境和开发工具在整合Spring，SpringMVC 和 MyBatis 的过程中，很容易遇到一些小问题，因此记录下整合过程。 首先是安装环境和开发工具，如下： Window 7 Jdk 1.8 MySql 8.0 Maven 3.5.4 Tomcat 8.5.34 IntelliJ IDEA 2018 二、整体项目结构整个项目在Maven WebApp模板工程的基础上构建，不同类型的文件放置于不同的包或者路径下，全部配置完成后的工程结构如下图所示： 不同路径下的文件归类说明如下表(classpath相当于resources文件夹)： 包名/路径名 作用 controller 存放控制器 mapper DAO层接口 pojo 实体类 service 业务类（接口+实现） /com/cr/mapper 对应mapper下接口的xml文件 /spring 与spring相关的配置文件 /webapp/jsp 存放jsp文件 /*.properties 资源文件 三、配置步骤1、添加Maven依赖 新建一个Maven WebApp工程，在pom.xml添加依赖，主要包括spring、springmvc、 mybatis、mybatis-spring 、servlet 、mysql 等项的jar包。 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cr&lt;/groupId&gt; &lt;artifactId&gt;SSMTest&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSMTest Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.9.3&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--添加Spring MVC的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加Servlet的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--JSTL用于在控制器中将模型绑定到JSP中--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加spring的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--利用它处理事务问题--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加数据库Mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--驱动版本号一定要装正确 否则连不上 mysql 5.1.46 可以适用本机--&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加Mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合Mybatis与Spring的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis分页依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 处理时间日期格式 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 用于MD5加密 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加Json依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--有时候不加可能会报错--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;!-- 新添加处理json为java bean --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传 高版本可以使用Multipart解析器 就不用引入这个包了 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源的引入， 池化技术 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSMTest&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 添加完成后的maven依赖如下： 2、配置web.xml spring上下文文件路径配置 12345&lt;!--配置Spring IoC的配置文件路径 classpath相当于resources文件夹--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 这里指定了上下文配置文件为spring文件夹下的applicationContext.xml，稍后再配置这个文件。 Log4j配置 1234&lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;60000&lt;/param-value&gt;&lt;/context-param&gt; ContextLoaderListener监听器配置 1234567&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 防止Spring内存溢出监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;&lt;/listener&gt; DispatcherServlet前置控制器配置 1234567891011&lt;servlet&gt; &lt;!--springmvc框架默认自动找到/WEB-INF/springmvc-servlet.xml作为配置文件载入web工程中 这里手动设置位置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt; springmvc框架默认自动找到/WEB-INF/[servlet-name]-servlet.xml作为配置文件载入web工程中 这里手动设置位置为spring文件夹下的springmvc-servlet.xml，稍后再配置这个文件。 Servlet拦截设置 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- Spring配置 --&gt; &lt;!-- ================================================= --&gt; &lt;!--配置Spring IoC的配置文件路径 classpath相当于resources文件夹--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Log4j配置--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;60000&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置ContextLoaderListener初始化IOC容器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring mvc配置 --&gt; &lt;!-- ================================================= --&gt; &lt;!--DispatcherServlet前置控制器配置--&gt; &lt;servlet&gt; &lt;!--springmvc框架默认自动找到/WEB-INF/springmvc-servlet.xml作为配置文件载入web工程中 这里手动设置位置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;!--拦截内容：servlet映射设置--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3、applicationContext.xml配置 在spring文件夹下建立applicationContext.xml applicationContext.xml 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--引入spring和其他整合的配置文件 比如spring-mybatis.xml等--&gt; &lt;import resource="classpath:spring/spring-*.xml"/&gt;&lt;/beans&gt; 这里引入spring和其他整合的配置文件 比如spring-mybatis.xml等，接下来在spring文件夹下新建一个spring-mybatis.xml文件 4、spring-mybatis.xml配置 配置自动扫描，需要扫描到控制层和服务层，刚开始我这里写成了com.cr.mapper，结果导致控制器不能注入 1&lt;context:component-scan base-package="com.cr" /&gt; 新建数据库资源文件jdbc.properties，针对不同的数据库需要修改配置 同时要注意匹配数据库的版本号，比如我安装的是MySQL 8.0，之前由于驱动版本弄错了，所以总是连接数据库失败，后来改成5.1.46才解决了问题 12345678910111213141516# 针对不同的数据库需要修改配置 同时要注意匹配数据库的版本号mysql.driver=com.mysql.jdbc.Drivermysql.url=jdbc:mysql://localhost:3306/mybatismysql.username=rootmysql.password=XXXX#定义初始连接数dbcp.initialSize=0#定义最大连接数dbcp.maxActive=20#定义最大空闲dbcp.maxIdle=20#定义最小空闲dbcp.minIdle=1#定义最长等待时间dbcp.maxWait=60000 引入数据库资源文件 1234&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt;&lt;/bean&gt; 配置数据库MySQL 12345678910111213&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;mysql.driver&#125;" /&gt; &lt;property name="url" value="$&#123;mysql.url&#125;" /&gt; &lt;property name="username" value="$&#123;mysql.username&#125;" /&gt; &lt;property name="password" value="$&#123;mysql.password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;dbcp.initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;dbcp.maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;dbcp.maxIdle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;dbcp.minIdle&#125;" /&gt; &lt;property name="maxWait" value="$&#123;dbcp.maxWait&#125;" /&gt;&lt;/bean&gt; 整合Spring和MyBatis，注意路径的书写方式是”/“不是”.” 1234567891011&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 注意路径是"/"不是"."--&gt; &lt;property name="mapperLocations" value="classpath:com/cr/mapper/*.xml" /&gt; &lt;property name="configuration"&gt; &lt;!--可以将之前mybatis.cfg.xml的一些配置项转移到这里来--&gt; &lt;bean class="org.apache.ibatis.session.Configuration"&gt; &lt;property name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 扫描持久层接口 1234&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.cr.mapper" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;&lt;/bean&gt; 数据库事务管理 1234&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; spring-mybatis.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 自动扫描包 包括了控制层和服务层 --&gt; &lt;context:component-scan base-package="com.cr" /&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;mysql.driver&#125;" /&gt; &lt;property name="url" value="$&#123;mysql.url&#125;" /&gt; &lt;property name="username" value="$&#123;mysql.username&#125;" /&gt; &lt;property name="password" value="$&#123;mysql.password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;dbcp.initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;dbcp.maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;dbcp.maxIdle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;dbcp.minIdle&#125;" /&gt; &lt;property name="maxWait" value="$&#123;dbcp.maxWait&#125;" /&gt; &lt;/bean&gt; &lt;!-- 整合Spring和MyBatis，就不需要之前的mybatis配置文件了 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 注意路径是"/"不是"."--&gt; &lt;property name="mapperLocations" value="classpath:com/cr/mapper/*.xml" /&gt; &lt;property name="configuration"&gt; &lt;!--可以将之前mybatis.cfg.xml的一些配置项转移到这里来--&gt; &lt;bean class="org.apache.ibatis.session.Configuration"&gt; &lt;property name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描DAO持久层接口 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.cr.mapper" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 数据库事务管理 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt;&lt;/beans&gt; 5、springmvc-servlet.xml配置 springmvc-servlet.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"&gt; &lt;!-- scan the package and the sub package --&gt; &lt;context:component-scan base-package="com.cr.controller"/&gt; &lt;!-- don't handle the static resource --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- if you use annotation you must configure following setting --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- configure the InternalResourceViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"&gt; &lt;!--相当于寻找/jsp/xxx.jsp文件--&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/jsp/" /&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 6、建立实体类 在pojo包下新建一个实体User类，包含用户名username 和 密码password 字段，alt + insert 生成 setter和getter方法 User.java 1234567891011121314151617181920212223package com.cr.pojo;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 7、DAO层建立 创建测试用表t_user，并添加两条数据 在mapper包下新建一个UserMapper接口，包含一个select查询方法，可以查询用户是否存在，若不存在返回null UserMapper.java 1234567package com.cr.mapper;import com.cr.pojo.User;public interface UserMapper &#123; User select(User user);&#125; 创建UserMapper和mybatis映射文件 UserMapper.xml，路径是resource/com/cr/mapper UserMapper.xml 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.cr.mapper.UserMapper"&gt; &lt;select id="select" parameterType="com.cr.pojo.User" resultType="com.cr.pojo.User"&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 8、服务层建立 建立UserService接口，位于service包下 UserService.java 12345678910package com.cr.service;import com.cr.pojo.User;public interface UserService &#123; /** * 根据user信息检查数据库中是否存在该用户 */ User get(User user);&#125; 在service包下建立impl子包，添加实现类UserServiceImpl UserServiceImpl.java 1234567891011121314151617181920package com.cr.service.impl;import com.cr.mapper.UserMapper;import com.cr.pojo.User;import com.cr.service.UserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;// @Service用于业务层 功能等同于@component@Service("userService")public class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override public User get(User user) &#123; // 通过Mapper的select方法查询用户 return userMapper.select(user); &#125;&#125; 9、建立控制器 在controller包下建立控制器UserController，根据表单的用户名和密码，在数据中匹配，如果存在该用户，则跳转到登录成功界面user.jsp，如果用户不存在则返回null，重定向回登录界面，以便于重新登录。 UserController.java 1234567891011121314151617181920212223242526272829303132333435package com.cr.controller;import com.cr.pojo.User;import com.cr.service.UserService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;// spring-mybatis.xml和springmvc-servlet.xml都配置了扫描控制层@Controllerpublic class UserController &#123; // 注入UserService @Resource private UserService userService; @RequestMapping(value = "/login") public String login(User user) &#123; ModelAndView mv = new ModelAndView(); System.out.println("开始查询---"); user = userService.get(user); if (user != null) &#123; System.out.println("查到的User: " + user.getUsername()); mv.addObject("user", user); // 转到user.jsp用户界面 return "user"; &#125; else &#123; System.out.println("未查到此用户"); // 查不到用户信息，则重定向回登录界面 System.out.println("重定向回登录界面---"); return "login"; &#125; &#125;&#125; 10、建立Jsp页面 login.jsp 123456789101112131415161718192021222324252627282930&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户登录界面&lt;/h1&gt;&lt;h2&gt;用户信息&lt;/h2&gt;&lt;h3&gt;Tom 123&lt;/h3&gt;&lt;h3&gt;Jack 456&lt;/h3&gt;&lt;br&gt;&lt;form id="form" action="/login" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input id="username" name="username" value="" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input id="password-always-checkbox" name="password" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align="right"&gt;&lt;input type="submit" value="提交"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; user.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;User&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户登录成功&lt;/h1&gt;&lt;br&gt;欢迎您: $&#123;user&#125;&lt;/body&gt;&lt;/html&gt; 四、部署项目1、Tomcat配置 2、启动服务器 浏览器访问http://localhost:8080/login 填写错误的用户名或者密码，浏览器将重新返回登录界面，控制台显示如下： 填写正确的用户名Tom和密码123，跳转到登录成功界面user.jsp，显示如下： 以上说明SSM框架整合成功。项目下载地址：https://github.com/wychencr/SSM-Test 五、一些注意事项 MySQL的驱动要匹配本机安装的版本 resources文件夹要被标记为Resource Root xml配置文件中的classpath相当于/resources IDEA可能会提示上下文配置文件没有添加，只要打开工程结构选项，把当前xml文件添加到工程中即可 注意各个xml配置文件中扫描包的位置，如果有遗漏就会报错 注意各个jar包的版本问题，我原来使用最新的Mybatis 3.4.6就会出现报错 java.lang.IllegalAccessError: org.apache.commons.dbcp.DelegatingPreparedStatement.isClosed() 修改版本为3.2.6后解决问题]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绑定个人域名与Github pages]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%B8%8EGithub-pages%2F</url>
    <content type="text"><![CDATA[一、申请个人域名本文承接 使用Hexo和Github建立个人主页 当我们使用Hexo在github pages上部署好个人页面后，就可以通过username.github.io访问了，接下来要做的就是申请一个属于自己的域名，然后将域名与上述的网址绑定起来，这样就可以通过个人域名来访问自己个人站点了。 1、申请来源 国内服务商我们可以阿里云或者腾讯云，国外服务商可以选择GoDaddy，支持支付宝支付。 申请的域名根据珍惜程度，或者域名使用时间，需要收取不同的费用。对于个人域名来说，腾讯云或者阿里云上面的活动价格每年最低只要几元。 freenom 是一个可以申请免费域名的网站，在freenom上面可以申请到免费的顶级域名.tk .ml .ga .cf .gq 。 2、顶级域名参考自3分钟弄明白顶级域名二级域名子域名父域名的区别 顶级域名 Top-level domains，first-level domains（TLDs） :是互联网DNS等级之中的最高级的域，保存于DNS根域的名字空间中。顶级域名是域名的最后一个部分，即是域名最后一点之后的字母，比如常见的.com 顶级域名分为4类 通用顶级域 ：如”.com”、”.net”、”.org”、”.edu”、”.info”等，均由国外公司负责管理 国家及地区顶级域 ：如”.cn”代表中国，”.uk”代表英国等，地理顶级域名一般由各个国家或地区负责管理。 基础建设顶级域 测试顶级域 比如上述的.tk域名是南太平洋岛国托克劳的顶级域名, .ml 是非洲国家马里的后缀, .ga 域名为加蓬国家顶级域名后缀, .cf 是中非共和国的后缀, .gq域名是赤道几内亚国家地区顶级域名。 3、注册freenom freenom的官方网站 这个网站一般都不是很稳定，建议使用vpn登入，首先要注册一个账号，直接使用谷歌邮箱注册即可，使用国内的邮箱应该不可以，收不到邮件验证码。 4、检索域名在首页的搜索框中，输入自己想申请的域名名称，点击检查可用性按钮，可以看到前面几个免费的顶级域名 点击现在获取按钮，加入购物车 Period 选择12个月免费，如果超过12个月就需要收费了。 当域名快到期时，freenom会发邮件提醒，可以直接再续期一年。 然后点击Continue按钮。 在Review &amp; Checkout界面，填写一些基本信息，点击complete order即可。 这样一个属于自己域名就申请并购买完成了。 值得注意的是，这些申请的免费域名不需要备案，对搜索引擎的友好度也不高，并且不算稳定，可能会被freenom突然收回，如果需要稳定性，建议选择付费域名。 二、freenom域名解析1、设置DNS进入我的域名界面，点击Manage Domain按钮 点击Manage Freenom DNS按钮 添加两条记录，按照如下设置即可。 1234Name: 空/wwwType: CNAMETTL: 14440(默认)Target: &lt;username&gt;.github.io 网上很多说法都是使用A类型解析，需要填写github的ip地址或者ping自己username.github.io的IP地址，我经过测试，只需要填写CNAME解析即可。 相关参数的含义如下： 2、关联github pages登录github，进入username.github.io这个仓库，点击Setting，往下翻，找到github pages的设置项。 在自定义域名栏输入刚刚申请到的域名名称，不需要加http或https前缀，点击Save即可。 刷新后，进入仓库，可以看到多了一个CNAME文件，里面的内容就是我们的域名名称。 大约等10分钟后，就可以通过域名访问到我们的个人站点了。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>freenom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用的常用命令]]></title>
    <url>%2F2018%2F10%2F19%2FGit%E4%BD%BF%E7%94%A8-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、git工作流程 Workspace工作区：是当前工作目录，可以在此目录编辑文件 Index缓存区：add指令，保存文件的改动 Repository仓库：commit指令，将多次的文件改动最后提交 Remote远程仓库：可以将本地仓库代码传到远程仓库上，方便多人远程协作 二、常用操作1、初始化仓库1$ git init 2、加到缓存区12345678# 指定文件，提交到暂存区$ git add &lt;filename&gt;# 将工作区的变化提交到暂存区，包括文件修改和新增，但是不包括删除的文件$ git add .# 将工作区的变化提交到暂存区，包括新增，删除和修改的所有内容$ git add -A 3、提交到版本库12# 将修改从暂存区提交到版本库，并添加备注message$ git commit -m “message” 4、查看信息123456789101112131415161718# 查看上次提交之后是否有修改$ git status# 查看上次提交之后是否有修改，简短输出结果$ git status -s# 查看尚未缓存的改动$ git diff# 查看已缓存的改动$ git diff -cached# 查看已缓存的与未缓存的所有改动$ git diff HEAD# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示指定文件相关的每一次diff$ git log -p [file] 5、回退操作1234567891011121314# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard 6、分支操作123456789101112131415161718192021222324252627282930# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 7、克隆仓库123# repo:Git 仓库 directory:本地目录$ git clone &lt;repo&gt;$ git clone &lt;repo&gt; &lt;directory&gt; 8、与远程仓库同步12345678# 增加一个新的远程仓库，并命名$ git remote add [origin] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch]]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Github建立个人主页]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[前言在网上搜索一些技术问题时，经常会看到一些非常简约大气的个人博客站点，所以也非常希望自己也可以搭建一个类似的个人站点。后来得知可以借助于Hexo和Github方便的生成属于自己的个人主页。 Hexo是一个快速、简洁且高效的博客框架。Hexo 使用（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 同时Hexo也支持丰富的主题模板，在此基础上，经过简单几步指令的执行，就可以生成非常美观的个人站点。 Github提供静态网站托管服务 ，我们可以将Hexo生成的网页项目托管到Github上，这样就可以通过互联网随时随地访问我们的网站，并且 GitHub Pages 支持绑定个人域名，本文也会介绍如何在freenom上申请域名，然后绑定到GitHub Pages，这样就可以通过个人域名访问自己的网站了。 一、安装环境准备1、检测环境变量在安装Hexo之前，需要安装Git 和Node.js 。 Git是一个开源的分布式版本控制系统 ，通过它可以将我们的本地代码库方便推送到远程仓库Github。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 ，Node.js 的包管理器 npm，是全球最大的开源库生态系统，npm类似于python中的pip。稍后便可以使用npm来安装Hexo 。 如果电脑之前安装过Git和Node.js，那么可以检测下安装环境，看是否正确安装。 检测方法，win+R键，输入cmd，在控制台窗口依次输入以下3条指令检查版本，如果都可以正确返回，说明安装没有问题。 123git --versionnode -vnpm -v 由于我的电脑之前就安装过git，但是可能环境变量出了问题，导致后面无法部署，之后添加了git/cmd环境变量，hexo环境变量又出了问题，添加了hexo，node环境变量又出了问题，之后干脆全部卸载重装了，所以检测这一步非常必要。 2、安装Git进入Git官网，下载对应版本的安装包，如果是windows，直接默认下一步安装即可，详细的安装过程和安装选项参见这篇文章： Git中文详细安装教程 3、安装Node.jsNode.js的安装也十分简便，直接去官网下载安装包，默认下一步安装即可。 安装完成后，再进行上面的检测，如果出现命令不能识别的情况，可能需要手动添加环境变量，或者重新安装。 二、Git和Github配置1、注册github账号首先需要一个github账号，如果还没有注册，进入官网注册即可，由于服务器在国外，访问速度可能不是很快。 2、创建仓库Github pages服务默认的仓库名是&lt;你的github用户名&gt; + github.io 所以需要建立一个这样的代码库，以便于存储我们的网站代码。 建立过程如下： 进入自己的github主页，点击左边的New repository按钮 Repository name填写&lt;你的github用户名&gt; + github.io，比如我的账号是wychencr，那么仓库名一定要填写wychencr.github.io，这里不能填错了 Description 可以填写一段文字描述，随便都可以，仓库属性选择public Initialize this repository with a README 可以不勾选 最后点击Create repository按钮即可 3、Git设置用户名与邮箱在桌面或其他任意位置，右键，选择git bash here，然后执行以下两条指令，”Your Name”和”email@example.com“分别填写自己的用户名和邮箱，如果之前就安装过git并且设置了个人信息，就可以忽略这个步骤。 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 4、使用SSH连接Git与Github后面我们经常需要将本地代码通过git推送到github上，为了避免每次都输入密码，所以使用SSH连接。 SSH( Secure Shell )是一种安全协议，详细介绍参加这篇博文：详述SSH的原理及其应用 将Git与Github连接分为以下两步完成： 生成SSH公钥和秘钥在桌面或其他任意位置，右键，选择git bash here，然后执行以指令 1$ ssh-keygen -t rsa 表示使用RSA算法生成key，指令执行期间一直回车就可以了，最后会在用户文件夹下生成两个文件“id_rsa”和“id_rsa.pub” ，如图所示： “id_rsa.pub”对应的就是公钥，在C盘找到它，用记事本打开这个文件，复制其内容。 添加SSH公钥到github登录github账号，点击右上角的头像，选择Setting，在左侧Personal settings菜单栏选择SSH and GPG keys ，然后点击右上角的New SSH Key，将“id_rsa.pub”的内容复制到输入框中，标题title可以不填，注意SSH key 代码的前后不要留多余的空格或者回车。 添加完成后如下图所示： 这样，在传输时，远程的公钥就可以与本地的秘钥进行匹配了。 验证是否连接成功在 git bash 中输入以下指令： 1$ ssh -T git@github.com 看到以上结果说明SSH匹配成功。 三、安装Hexo1、使用npm安装Hexo进入cmd界面，输入以下指令即可安装好Hexo： 1$ npm install -g hexo-cli 如下图所示，可能等待时间稍长，我这里花了将近3分钟。 2、建立网站首先在本地电脑建立一个文件夹，用于管理和存储网站的代码，文件夹路径尽量不要有中文或者空格，避免出现意外的问题，比如我在E盘根目录建立一个HexoBlog文件夹。 然后执行下列三条指令即可建立好最基本的网站，非常便捷。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install &lt;folder&gt;是刚刚在本地建立的文件夹名称，比如我建立的文件夹是HexoBlog，所以我执行的指令就是 123$ hexo init HexoBlog$ cd HexoBlog$ npm install 过程如下图所示： 此时打开E:\HexoBlog\HexoBlog目录，可以看到生成的文件目录结构为： 12345_config.yml: 网站的配置信息，您可以在此配置大部分的参数package.json: 应用程序的信息scaffolds: 模版文件夹。当新建文章时，Hexo会根据scaffold来建立文件source: 存放用户资源的地方,比如用户新建的博客文章themes： 主题文件夹，Hexo会根据主题来生成静态页面 3、启动本地服务器 执行以下指令，启动本地服务器 1$ hexo server 浏览器中访问 http://localhost:4000/ 即可浏览到Hexo生成的最基本的网站 如果出现 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000 浏览器访问地址改成http://localhost:5000 四、新建和部署文章1、新建一篇文章1$ hexo new &lt;title&gt; &lt;title&gt;是文章标题，执行上述指令后，在/sources/_post文件夹下就会产生一个名为“title”的md文件，编辑它即可。 2、生成静态文件12$ hexo generate$ hexo g # 简写 当代码仓库中有文件改变时，执行上述指令可以重新生成静态文件，使改动生效。 3、本地查看效果在改动项目之后，可以先启动本地服务，在4000端口查看是否是自己预期的结果，如果没有问题，在部署到远程仓库。 12$ hexo server$ hexo s # 简写 4、部署到github此步骤可以将本地生成的项目文件推送部署到远程仓库，这样就可以使用username.github.io这样链接来访问我们的网站了。 12$ hexo deploy$ hexo d # 简写 如果是第一次部署，需要修改配置文件/HexoBlog/_config.yml： 1234deploy: type: git repo: &lt;repository url&gt; branch: [branch] [repository url]：填写之前新建的那个仓库地址，填写SSH地址，形式是 git@github.com:/.github.io.git [branch]：默认master 然后执行以下指令： 12$ npm install hexo-deployer-git --save$ hexo d 执行成功后，在github上的仓库中可以看到被部署的文件，稍微等待一段时间，就可以通过username.github.io访问到页面了。 五、更改Hexo主题1、下载主题在Hexo的主题商店 可以看到各种主题，选择自己喜欢的主题，下载压缩包，解压，放到/theme文件夹下。 以Next主题为例，首先访问Next的github仓库，下载解压，重命名为“next”，放入/theme文件夹下。 2、修改项目配置文件项目配置文件位于/HexoBlog/_config.yml，修改theme项为next： 1theme: next 注意冒号和next之间有一个空格。 3、修改主题配置文件主题配置文件位于/HexoBlog/themes/next/_config.yml。 Next主题支持四种样式效果，预览效果见官方说明文档 1234Muse 方案: LEAFERx | XiaMo | OAwansix_pointed_star Mist 方案: Jeff | uchuhimo | xirongpisces Pisces 方案: Vi | Acris | Rainygemini Gemini 方案: Ivan.Nginx | Raincal | Dandy 修改Schemes 1234scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 默认是第一种，如果想改成其他效果，只要把对应项的注释取消，再把第一项注释掉即可。 修改语言 12/HexoBlog/_config.yml# language: zh-Hans 添加评论系统 进入来必力官网，使用谷歌邮箱注册登录，获取uid，然后复制到主题配置文件的livere_uid处： 添加一个标签/分类页面/社交媒体/Feed link 见官方说明文档 更多配置技巧见知乎专栏：Hexo搭建的GitHub博客之优化大全 六、一些注意事项1、博客文章中带图片的情况网上比较普遍的方案是安装一个图片上传插件，然后改成配置文件，再在资源文件夹下建立一个img文件夹，然后将图片都放到img文件夹中，然后在博文中使用相对路径。 这样做有两个问题： 一是操作相对繁琐，而是增加了仓库所占的容量，在推送到远程仓库时也会更加缓慢； 二是github pages对仓库容量有限制，不超过300M 因此推荐使用微博图床，可以在Chrome商店中搜索“微博图床”扩展，下载，之后登陆微博中账号就可以使用了。 2、Markdown写作工具推荐Typora，下载地址https://www.typora.io/ Typora是一款好用极简免费的跨平台Markdown编辑器，软件使用这款软件能够帮助用户轻松将文本转换到HTML，软件从底层向上设计，软件支持markdown的标准语法，同时这款软件还支持动态预览功能，一键预览，让一切都变得如此干净、纯粹，是一款不可多得的优质markdown编辑器。 3、Next主题自动生成目录 如果不想目录自动编号，修改主题设置文件，将number:改为false： 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 自动生成目录混乱问题 父标题与子标题之间不能跨等级 123456H2 H4 H4H2 H4 ... 这样的结构可能就会出现问题，修改为连续的等级即可。 4、标注文章的分类和标签1234567title: xxxdate: 2018-10-18 15:14:41tags:- tag_A- tag_Bcategories:- categorie_C 5、CNAME文件被覆盖的问题当将github pages的url与自己的域名绑定后，在仓库中会生成一个CNAME文件，记录了域名。但是每次从本地部署代码后，github仓库中的CNAME文件就会被删除。 解决这个问题，可以把CNAME文件下载下来，放到仓库的/source文件夹中，再部署，就不会被覆盖了。 6、Hexo源文件的备份我们上传到github上的实际上是本地源代码库生成的静态文件，位于/public文件路径下。而我们的配置文件和博客.md文件等实际上都没有上传，如果硬盘除了问题，可能就没办法恢复了，所以需要备份本地源代码库，可以将其上传到github中，这样当我们更换电脑环境时，也可以重新从github上把源代码clong下来。 一种比较推荐的方法是，在github仓库中新建一个分支，保存源代码，另一个保存静态文件。 每次更改本地文件时，分别对两个分支执行deployed和push命令，这样就可以在生成静态文件的同时，也备份了源代码。 详细操作参见这篇博文： Hexo博客备份 当然，也可以新建一个github远程仓库，在本地将源代码仓库复制一份到硬盘的其他分区，备份到对应的远程仓库上，然后每次更新博文时，复制一份md文件到这个本地备份文件夹，再执行push操作，将md文件备份到远程仓库上。 当更换环境时，将备份仓库clone下来，安装Hexo环境，再重新生成部署即可。 这样做的好处是避免了分支操作，防止弄混淆，代价是多了一次复制操作，但是同时也算是给本地备份增加了一份保障。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法学习总结]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[动态规划与贪心、分治的区别 贪心算法(Greed alalgorithm) 是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致全局结果是最好或最优的算法。 分治算法(Divide and conquer alalgorithm) 字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 动态规划算法(Dynamic programming，DP) 通过将原问题分解为相对简单的子问题的方式来求解复杂问题。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 贪心法在处理每个子问题时，不能回退，而动态规划可以保存之前的结果，择优选择。下面针对Interval Scheduling 问题，分析动态规划在实际问题中的应用。 Interval Scheduling 问题 如下图所示，每个长条方块代表一个工作，总有若干个工作a、b… h，横坐标是时间，方块的起点和终点分别代表这个工作的起始时间和结束时间。 当两个工作的工作时间没有交叉，即两个方块不重叠时，表示这两个工作是兼容的(compatible)。 当给每个工作赋权值都为1时，则称为 Unweighted Interval Scheduling 问题；当给每个工作赋不同的正权值时，则称为 Weighted Interval Scheduling 问题。 问题最终是要找到一个工作子集，集合内所有工作权值之和最大且集合内每个工作都兼容。 对于 Unweighted Interval Scheduling 问题，使用贪心算法即可求解，具体做法是按照结束时间对所有工作进行排序，然后从结束最晚的工作开始，依次排除掉与前一个不兼容的工作，剩下的工作所组成的集合即为所求。 然而，对于 Weighted Interval Scheduling 问题，贪心法找到的解可能不是最优的了。此时考虑使用动态规划算法解决问题，兼顾权值选择和兼容关系。 定义P(j)1、首先依然按照结束时间对所有的工作进行排序； 2、定义p(j)为在工作j之前，且与j兼容的工作的最大标号，通过分析每个工作的起始时间和结束时间，可以很容易计算出p(j); 3、例如下图所示，p(8)=5，因为工作7和6都与8不兼容，工作1到5都与8兼容，而5是其中索引最大的一个，所以p(8)=5。同理，p(7)=3,p(2)=0。 分析递归关系1、定义opt(j)是j个工作中，所能选择到的最佳方案，即opt(j)是最大的权值和； 2、对于第j个工作，有两种情况： case 1: 工作j包含在最优解当中，那么往前递推一步，j之前能选择到的最优解是opt(p(j))，即 case 2: 工作j不在最优解中，那么从j个工作中选取解集和从j-1个工作中选取解集是一样的，即 3、当j=0时，显示结果为0，这是边界条件。 后一步的结果取前一步所有可能情况的最大值，因此综上所述，能得到动态规划的递归关系为： 代码实现1、递归法 递归会使得空间复杂度变高，一般不建议使用。 2、自底向上法 从小到大进行计算，这样每次都可以利用前一步计算好的值来计算后一步的值，算法时间复杂度为O(nlogn)，其中排序花费O(nlogn)，后面的循环花费O(n)。 Knapsack Problem 问题背包问题的定义 如下图所示，给定一个背包Knapsack，有若干物品Item 每个item有自己的重量weight，对应一个价值value 背包的总重量限定为W 目标是填充背包，在不超重的情况下，使背包内物品总重量最大。 对于下图的例子，一种常见的贪心思想是：在背包可以装得下的情况下，尽可能选择价值更高的物品。那么当背包容量是W=11时，先选择item5，再选择item2，最后只能放下item1，总价值为28+6+1=35。实际上最优解是选择item3和item4，价值18+22=40。这说明了贪心算法对于背包问题的求解可能不是zuiyou的。下面考虑使用动态规划算法求解，首先要推导递归关系式。 推导递归关系式类似于Weighted Interval Scheduling问题，定义opt(i, w)表示在有i个item，且背包剩余容量为w时所能得到的最大价值和。 考虑第i个item，有选和不选两种情况： case 1: 如果选择第i个item，则 case 2: 如果不选择第i个item，则 边界条件: 当i=0时，显然opt(i,w)=0。 后一步的结果取前一步所有可能情况的最大值，因此综上所述，能得到动态规划的递归关系为： 自底向上求解 算法迭代过程如下表： 算法运行时间分析 值得注意的是，该算法相对于输入尺寸来说，不是一个多项式算法，虽然O(nW)看起来很像一个多项式解，背包问题实际上是一个NP完全问题。 为了便于理解，可以写成这种形式： W在计算机中只是一个数字，以长度logW的空间存储，非常小。但是在实际运算中，随着W的改变，需要计算nW次，这是非常大的（相对于logW来说）。例如，当W为5kg的时候，以kg为基准单位，需要计算O(5n)次，当W为5t时，仍然以kg为单位，需要计算O(5000n)次，而在计算机中W的变化量相对很小。 Sequence AlignmentDefine edit distance给定两个序列x1,x2…xi和y1,y2,…,yj。要匹配这两个序列，使相似度足够大。首先需要定义一个表示代价的量-Edit distance，只有优化使这个量最小，就相当于最大化匹配了这两个序列。 Edit distance的定义如下所示。 其中，匹配到空，设距离为delta，否则字母p和q匹配的距离记为alpha(p,q)，如果p=q，则alpha=0； 那么两个序列匹配的总代价为： 建立递推关系设opt(i,j)是序列x1,x2…xi和y1,y2,…,yj之间匹配所花费的最小代价。当i，j不全为0时，则分别有三种情况，分别是xi-gap，yj-gap，xi-yj，分别计算不同匹配情况所花费的代价，再加上前一步的结果，就可以建立递推关系式，如下所示。 算法实现 算法复杂度时间和空间复杂度皆为O(mn)。 下面再分析一个具体的编程问题，使用动态规划算法，但是和上面的DP又有一些区别。 合唱团问题问题定义 有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？ 输入描述 每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;= n &lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;= ai &lt;= 50）。接下来的一行包含两个整数，k 和 d (1 &lt;= k &lt;= 10, 1 &lt;= d &lt;= 50)。 输出描述 输出一行表示最大的乘积。 问题分析 此题的第一个关键点是“要求相邻两个学生的位置编号的差不超过 d”，如果按照传统的DP思路，定义opt(i,k)表示在前i个学生中选取k个学生的最大乘积，建立递推关系: 则无法实现“相邻两个学生的位置编号的差不超过 d”的要求。因此，需要定义一个辅助量，来包含对当前学生的定位信息。 定义f(i,k)表示在前i个学生中选取k个学生，且第i个学生必选时，所选学生的能力值乘积，这样就包含对当前学生的定位信息，f的递推关系可以表示为 其中，j是一个比i小的值，最大为i-1，i、j之差不超过D，f(j,k-1)表示在前j个学生中，选择k-1个学生，且第j个学生必选。f(i,k)选择了第i个学生，f(j,k-1)选择了第j个学生，i、j之差不超过D，这样就可以满足题目要求了。 辅助量f(i,k)并不是我们最终要得到的结果，最终结果opt(i,k)表示在前i个学生中选取k个学生的最大乘积，因此，可以得到opt(i,k)和f(i,k)的关系为： 该问题的第二个关键点是学生的能力值在-50到+50之间，每次选择的学生的能力值有正有负，所以需要两个f记录最大和最小值，定义fmax和fmin，在每次迭代f的过程中： 当k=K，i=N时，最终所求的: 边界条件k=1时，f(i,k=1)=v(i) 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*********************************************************************** Ran Chen &lt;wychencr@163.com&gt;** Dynamic programming algorithm**********************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N, D, K; // 总共N个学生 vector &lt;int&gt; value; while (cin &gt;&gt; N) &#123; for (int i = 0; i &lt; N; ++i) &#123; int v; cin &gt;&gt; v; value.push_back(v); &#125; break; &#125; cin &gt;&gt; K; // 选择K个学生 cin &gt;&gt; D; // 相邻被选择学生的序号差值 // fmax/fmin[i, k]表示在选择第i个数的情况下的最大/小乘积 vector &lt;vector &lt;long long&gt;&gt; fmax(N+1, vector &lt;long long&gt; (K+1)); vector &lt;vector &lt;long long&gt;&gt; fmin(N+1, vector &lt;long long&gt; (K+1)); // 边界条件k=1 for (int i = 1; i &lt;= N; ++i) &#123; fmax[i][1] = value[i - 1]; fmin[i][1] = value[i - 1]; &#125; // 自底向上dp, k&gt;=1 for (int k = 2; k &lt;= K; ++k) &#123; // i &gt;= k for (int i = k; i &lt;= N; ++i) &#123; // 0 &lt;= j &lt;= i-1 &amp;&amp; i - j &lt;= D &amp;&amp; j &gt;= k-1 long long *max_j = new long long; *max_j = LLONG_MIN; long long *min_j = new long long; *min_j = LLONG_MAX; // f(i, k) = max_j &#123;f(j, k-1) * value(i)&#125; int j = max(i - D, max(k - 1, 1)); for ( ; j &lt;= i - 1; ++j) &#123; *max_j = max(*max_j, max(fmax[j][k - 1] * value[i - 1], fmin[j][k - 1] * value[i - 1])); *min_j = min(*min_j, min(fmax[j][k - 1] * value[i - 1], fmin[j][k - 1] * value[i - 1])); &#125; fmax[i][k] = *max_j; fmin[i][k] = *min_j; delete max_j; delete min_j; &#125; &#125; // opt(N, K) = max_i &#123;f(i, K)&#125;, K &lt;= i &lt;= N long long *temp = new long long; *temp = fmax[K][K]; for (int i = K+1; i &lt;= N; ++i) &#123; *temp = max(*temp, fmax[i][K]); &#125; cout &lt;&lt; *temp; delete temp; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB安装libsvm工具箱的方法]]></title>
    <url>%2F2018%2F08%2F12%2FMATLAB%E5%AE%89%E8%A3%85libsvm%E5%B7%A5%E5%85%B7%E7%AE%B1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[支持向量机（support vector machine，SVM）是机器学习中一种流行的学习算法，在分类与回归分析中发挥着重要作用。基于SVM算法开发的工具箱有很多种，下面我们要安装的是十分受欢迎的libsvm工具箱。 libsvm简介 LIBSVM 是台湾大学林智仁(Lin Chih-Jen)副教授等开发设计的一个简单、易于使用和快速有效的 SVM 模式识别与回归的软件包，它不仅提供了编译好的可在 Windows 系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它操作系统上应用； 该软件还有一个特点，就是对 SVM 所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数就可以解决很多问题；并且提供了交互检验(Cross-SVM回归等问题，包括基于一对一算法的多类模式识别问题。 libsvm与MATLAB自带的svm工具箱的区别在MATLAB中，同样自带了一个svm工具箱，不过相比于libsvm，在功能性和易用性方面有一些差距。具体差别表现在： MATLAB自带的svm实现函数仅支持分类问题，不支持回归问题；而libsvm不仅支持分类问题，亦支持回归问题 MATLAB自带的svm实现函数仅支持二分类问题，多分类问题需按照多分类的相应算法编程实现；而libsvm采用一对一方法支持多分类 MATLAB自带的svm工具箱无法改变高斯核函数中的参数，而libsvm可以 MATLAB自带的svm工具箱也有一些优点，比如在解决二次规划问题时，可选三种方法（经典二次方法；SMO；最小二乘），而libsvm只能是SMO。 常见的扩展为多分类的方法有： 一对一（one-versus-one）方法，训练时对于任意两类样本都会训练一个二分类器，最终得到k(k-1)/2个二分类器，共同组成k分类器。对未知样本分类时，使用所有的k(k-1)/2个分类器进行分类，将出现最多的那个类别作为该样本最终的分类结果。 一对多（one-versus-rest）方法：训练时依次把k类样本中的某个类别归为一类，其它剩下的归为另一类，使用二分类的SVM训练处一个二分类器，最后把得到的k个二分类器组成k分类器。对未知样本分类时，分别用这k个二分类器进行分类，将分类结果中出现最多的那个类别作为最终的分类结果。 libsvm的下载在libsvm的官方主页上可以下载libsvm的扩展包，支持MATLAB、Java、Python等多种语言，这里我们选择MATLAB版本，下载zip文件即可。 或者直接下载我分享的文件包，点击这里下载 注意如果是从官方主页上下载，需要再下载一个数据集[heart_scale.mat]，方便之后的测试，点击这里下载。 如果是下载我分享的文件包，里面已经包含了这个数据集.mat文件，就不需要再下载了。 libsvm的安装在\libsvm-3.23\matlab目录下，有一个README文件，详细说明了安装方法。 如果是windows 64位系统，预编译的二进制文件已经提供，在\libsvm-3.23\windows文件下，可以看到4个文件，分别是libsvmread.mexw64、libsvmwrite.mexw64、svmtrain.mexw64、svmpredict.mexw64。 这样可以跳过下面第一步的编译步骤。 1.编译如果是win32位系统，需要自己重新编译c文件，生成MATLAB可识别的mexw32文件。编译方法在上述的README文件也有说明。 将MATLAB的工作文件夹调整到\libsvm-3.23\matlab目录下，在MATLAB的命令行窗口输入&gt;&gt; mex -setup，然后选择编译器如VS2010，最后输入指令&gt;&gt;make。编译完成后，当前路径下会生成对应的mexw32（32位系统）mexw64（64位系统）文件。 过程如下： 123456789101112131415161718192021matlab&gt;&gt; mex -setupWould you like mex to locate installed compilers [y]/n? ySelect a compiler:[1] Microsoft Visual C/C++ version 7.1 in C:\Program Files\Microsoft Visual Studio[0] NoneCompiler: 1Please verify your choices:Compiler: Microsoft Visual C/C++ 7.1Location: C:\Program Files\Microsoft Visual StudioAre these correct?([y]/n): ymatlab&gt;&gt; make 注意： 我的操作系统是win7 64位，原先安装的是MATLAB2014a和VS2015，发现并不支持libsvm工具包中提供好的mexw64文件，原因是MATLAB的版本过低。 随后我考虑重新编译生成适合自己版本的mexw64文件，结果发现MATLAB2014a不支持识别VS2015,最高支持到VS2013。 所以解决方法有两种，一种是给给VS降级，一种是给MATLAB升级。由于前者涉及很多.net和c++库文件，比较繁琐，所以最方便的做法是安装新版本的MATLAB，新老版本的MATLAB只要不安装在一个文件夹下，一般不会出现干扰情况。 安装MATLAB2016及以上版本就可以支持以上的mexw64文件，同时也能识别更新的c/c++编译器。 MATLAB 2016b的下载、安装、激活方法，可以参考这个链接。 2.重命名函数在得到libsvmread.mexw64、libsvmwrite.mexw64、svmtrain.mexw64、svmpredict.mexw64这4个文件后，为了避免和svm内置的函数冲突，最好将svmtrain.mexw64、svmpredict.mexw64这两个文件重命名为libsvmtrain.mexw64、libsvmpredict.mexw64。 3.添加到toolbox将libsvm-3.23文件夹放置到\MATLAB R2016b\toolbox目录下； 主页&gt; 设置路径&gt; 添加文件夹&gt; 选择libsvm-3.23文件夹； 添加并包含子文件夹&gt; 选择libsvm-3.23文件夹； 主页&gt; 预设&gt; 常规&gt; 更新工具箱缓存&gt; 确定 测试在MATLAB命令行窗口输入一下指令： 123load heart_scalemodel = libsvmtrain(heart_scale_label, heart_scale_inst, &apos;-c 1 -g 0.07&apos;);[predict_label, accuracy, dec_values] = libsvmpredict(heart_scale_label, heart_scale_inst, model); 若出现以下结果，说明安装正确。 更详细的关于libsvm的使用方法可以参考libsvm文件夹下的README文件或者是官方主页的说明。 References 支持向量机 - 维基百科，自由的百科全书 MATLAB自带的svm实现函数与libsvm差别 - CSDN博客 LibSVM 在 Matlab中的使用 - 星天炎地 | Dytan Blog Matlab + LibSVM + 问题集锦【20170407】 - CSDN博客 libsvm使用说明-码农场 MatLab2016b破解版安装教程 - CSDN博客 LIBSVM – A Library for Support Vector Machines]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>SVM</tag>
        <tag>Libsvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法 DFS深度优先搜索 （递归与非递归实现）]]></title>
    <url>%2F2018%2F08%2F07%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[回溯法是一种选优搜索法（试探法），被称为通用的解题方法，这种方法适用于解一些组合数相当大的问题。通过剪枝（约束+限界）可以大幅减少解决问题的计算量（搜索量）。 基本思想将n元问题P的状态空间E表示成一棵高为n的带权有序树T，把在E中求问题P的解转化为在T中搜索问题P的解。 深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。 –from wiki 实现方法1、按选优条件对T进行深度优先搜索，以达到目标。 2、从根结点出发深度优先搜索解空间树 3、当探索到某一结点时，要先判断该结点是否包含问题的解 如果包含，就从该结点出发继续按深度优先策略搜索 否则逐层向其祖先结点回溯（退回一步重新选择） 满足回溯条件的某个状态的点称为“回溯点” 4、算法结束条件 求所有解：回溯到根，且根的所有子树均已搜索完成 求任一解：只要搜索到问题的一个解就可以结束 遍历过程 典型的解空间树第一类解空间树：子集树当问题是：从n个元素的集合S中找出满足某种性质的子集时相应的解空间树称为子集树，例如n个物品的0/1背包问题。 这类子集树通常有2^n个叶结点 解空间树的结点总数为2^(n+1) - 1 遍历子集树的算法需Ω(2^n)计算时间 第二类解空间树：排列树当问题是：确定n个元素满足某种性质的排列时相应的解空间树称为排列树，例如旅行商问题。 DFS搜索在程序中可以两种方式来实现，分别是非递归方式和递归方式。前者思路更加清晰，便于理解，后者代码更加简洁高效。 非递归实现非递归实现需要借助堆栈(先入后出，后入先出)，在C++中使用stack容器即可。 问题若给定一个序列，需要找到其中的一个子序列，判断是否满足一定的条件。下面将程序实现DFS对子序列的搜索过程。 实现步骤：1、首先将根节点放入堆栈中。 2、从堆栈中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜寻并回传结果。 否则将它某一个尚未检验过的直接子节点加入堆栈中。 3、重复步骤2。 4、如果不存在未检测过的直接子节点。 将上一级节点加入堆栈中。 重复步骤2。 5、重复步骤4。 6、若堆栈为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 C++代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*********************************************************************** Ran Chen &lt;wychencr@163.com&gt;** Back-track algorithm （by DFS）**********************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;class Node&#123;public: int num; // 节点中元素个数 int sum; // 节点中元素和 int rank; // 搜索树的层级 int flag; // 0表示子节点都没访问过，1表示访问过左节点，2表示访问过左右节点 vector &lt;int&gt; path; // 节点元素 Node(); Node(const Node &amp; nd);&#125;;// 默认构造函数Node::Node()&#123; num = 0; sum = 0; rank = 0; flag = 0; // path is empty&#125;// 复制构造函数Node::Node(const Node &amp; nd)&#123; num = nd.num; sum = nd.sum; rank = nd.rank; flag = nd.flag; path = nd.path;&#125;// -----------------------------------------------------------------void DFS(const vector &lt;int&gt; &amp; deque)&#123; stack &lt;Node *&gt; stk; // 存储节点对应的指针 stack &lt;Node *&gt; pre_stk; // 存储上一级节点（回溯队列） Node * now = new Node; // 指向当前节点 Node * next = NULL; // 指向下一个节点 Node * previous = NULL; // 指向上一个节点 while (now) &#123; if (now-&gt;rank &lt; deque.size() &amp;&amp; (now-&gt;flag == 0)) &#123; // 左叶子节点,选择当前rank的数字 next = new Node(*now); next-&gt;num++; next-&gt;sum += deque[next-&gt;rank]; next-&gt;path.push_back(deque[next-&gt;rank]); next-&gt;rank++; next-&gt;flag = 0; stk.push(next); // 将左节点加入堆栈中 now-&gt;flag = 1; // 改变标志位 // 将当前节点作为上一级节点存储并删除 previous = new Node(*now); pre_stk.push(previous); delete (now); // 取出堆栈中的待选节点作为当前节点 now = stk.top(); stk.pop(); // 显示搜索路径 for (int i = 0; i &lt; next-&gt;path.size(); ++i) &#123; cout &lt;&lt; " " &lt;&lt; next-&gt;path[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; continue; // DFS每次仅选取一个子节点，再进入下一步循环 &#125; if (now-&gt;rank &lt; deque.size() &amp;&amp; (now-&gt;flag == 1)) &#123; // 右节点，不选择当前rank的数字 next = new Node(*now); next-&gt;rank++; next-&gt;flag = 0; stk.push(next); now-&gt;flag = 2; // 将当前节点作为上一级节点存储并删除 previous = new Node(*now); pre_stk.push(previous); delete (now); // 取出堆栈中的待选节点作为当前节点 now = stk.top(); stk.pop(); continue; &#125; // 回溯结束 if (pre_stk.empty()) &#123; break; &#125; // 没有子节点或者没有未搜索过的子节点时，回退到上一级节点（回溯） if (now-&gt;rank &gt;= deque.size() || now-&gt;flag == 2) &#123; delete (now); now = pre_stk.top(); pre_stk.pop(); &#125; &#125;&#125;// -----------------------------------------------------------------int main()&#123; stack &lt;Node*&gt; stk; vector &lt;int&gt; deque &#123; 2,3,5,7 &#125;; DFS(deque); cin.get(); return 0;&#125; 运行结果 程序说明1、定义了一个Node节点类，表示当前状态下已经搜索到的序列，path记录了这个子序列的值，并且类中添加了num（子序列中元素数目）、sum（子序列元素和）等属性，通过这些属性可以判断是否找到满意解或者用于剪枝。 2、对于原始序列中某个位置的数，其子序列中可以包含这个数，也可以不包含这个数，所以每次有两种选择，即每个节点有两个子节点。 3、flag属性标识了当前节点的子节点遍历情况。若flag=0，表示子节点都没访问过，下一步优先访问左节点，所以将左节点加入堆栈中；flag=1，表示访问过左节点，下一步访问右节点；flag=2，表示访问过左右节点。 4、当没有子节点（now-&gt;rank &gt;= deque.size()）或者左右节点都访问过时（flag=2），回溯到上一级节点。 5、程序循环中，首先通过now当前节点，找到下一个子节点next，将其加入堆栈中，便于下一步循环。在now节点销毁前，将其存到previous，并加入pre_stk堆栈中。这样在下一轮循环中，previous相对于now就是上一级节点，如果now不能找到其子节点，就要返回上一级，这样previous就可以重新赋给now，达到返回上一级的目的。 6、整个程序的终止条件是pre_stk堆栈为空时截止，说明所有节点都已经遍历过，并且没有再可回溯的节点了。实际运用中，可以通过其他属性（搜索到可行解）来提前终止程序。 递归实现参考自Coding_Or_Dead的博客 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include &lt;iostream&gt;int n, k; __int64 sum = 0;int a[4] = &#123; 2, 3, 5, 7 &#125;, vis[4] = &#123;0, 0, 0, 0&#125;;void DFS(int i, int cnt, int sm)//i为数组元素下标,sm为cnt个数字的乘积&#123; if (cnt == k) // 解中已包含k个数字 &#123; sum = sum + sm; return; &#125; if (i &gt;= n) return; if (!vis[i]) &#123; // 对第i个数字进行访问 vis[i] = 1; //a[i]被选，优先选择第i个加入到解中，接下来搜索第i+1个数字 DFS(i + 1, cnt + 1, sm*a[i]); //a[i]不选，不选择第i个，相当于右节点，接下来搜素第i+1个数字 DFS(i + 1, cnt, sm); vis[i] = 0; // 回溯 &#125; return;&#125;int main(void)&#123; n = 4, k = 2; DFS(0, 0, 1); printf("%I64d\n", sum); std::system("pause"); return 0;&#125; 程序说明1、程序目的：给定n个正整数，求出这n个正整数中所有任选k个相乘后的和，这里的数组a[4]存储原序列，vis[4]作为访问标志，k取2，结果输出为101，对应的序列是{2, 3}{2, 5}{2, 7}{3, 5}{3, 7}{5, 7}。 2、对于元素a[i]，每次对应两个选择。若选择将a[i]加入到解中，则解中元素个数+1，乘积结果a[i]，所以下一步更新为`DFS(i + 1, cnt + 1, sma[i])。若不选择a[i]，则解中的元素个数和乘积不变，下一步更新为DFS(i + 1, cnt, sm)`。 3、回溯时要将标志位重置。 References 深度优先搜索 - 维基百科，自由的百科全书 DFS深度优先搜索(入门) - CSDN博客 广度优先搜索 BFS算法 - 东聃 - 博客园]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA连接数据库详细过程]]></title>
    <url>%2F2018%2F08%2F03%2FIntelliJ-IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言IntelliJ IDEA集成了众多插件，方便开发者使用，使用其自带的Database工具就可以很方便的配置、连接到数据库，本次操作以MySQL为例，其中testjdbc数据库已经提前建好，里面有两张表emp_table 和 t_user，相关信息如下图。 连接到MySQL数据库1、选择数据源在IDEA中新建一个Java工程后，最右侧侧边栏会有个 Database 标签，点击此标签，然后点击+按钮，选择Data Source，选择MySQL，如果是其他数据源，选择其他对应按钮即可。过程如下图所示。 2、下载驱动如下图是下载好MySQL驱动的情况。如果是第一次进入此界面并且没有驱动，IDEA会在Driver处提示没有下载对应数据库类型的驱动，直接点击，就会自动下载，稍作等待后，结果显示为MySQL，若点击此标签，可以对MySQL的驱动文件进行进一步配置。 3、配置账户、密码信息如上图所示，需要填写数据库账户信息，这里我的用户名User为root，由于是本地数据库，所以Host填写为localhost，端口Port为3306，Password填写用户名对应的密码即可，Database可以填写想连接的数据库名，也可以暂时不填，待连接上后再设置。填写以上所有信息后，点击Test Connection按钮，如果显示成功Successful，说明连接成功，点击OK按钮，配置完成。 4、查看、修改数据库 连接到数据库后，在Database标签下，可以查看数据库结果，如下图所示，可以看到testjdbc库下有两张表，分别是emp_table 和 t_user，并且能看到表的列信息。如下图所示。 点击表名或者列名，就可以查看表信息，也可以修改表信息，如下图所示。 使用JDBC操作数据库1、导入驱动包到工程 在Database标签下，右键刚刚建立的数据源名，选择属性Properties，进入之前配置数据源的界面，如下图所示。 点击Driver处MySQL，查看驱动信息，如下图所示。 查看驱动包在计算机中的位置，记下这个路径，方便后面导入这个jar包，如下图。 查看到MySQL驱动包的位置后，关闭窗口，在主界面点击File-&gt;Project Structure，进入工程设置界面。然后在左侧栏，点击Modules，再选择Dependencies，再点击右侧的+按钮，选择JARs or directories，找到上面MySQL驱动jar包的位置，选择这个jar文件。成功导入后，在Export栏下会有两项，分别是jdk和刚刚导入的jar包，如下图所示。 导入成功后，在工程目录External Libraries下面也会出现导入的驱动包名称，如下图所示。 2、使用jdbc操作数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.sql.*;public class ConnMySQL &#123; public static void main(String[] args) throws Exception &#123; Connection conn = null; try &#123; // 加载驱动类 Class.forName("com.mysql.jdbc.Driver"); long start =System.currentTimeMillis(); // 建立连接 conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc", "root", "【填写对应的密码】"); long end = System.currentTimeMillis(); System.out.println(conn); System.out.println("建立连接耗时： " + (end - start) + "ms 毫秒"); // 创建Statement对象 Statement stmt = conn.createStatement(); // 执行SQL语句 ResultSet rs = stmt.executeQuery("select * from t_user"); System.out.println("id\tusername\tpwd\t\tregTime"); while (rs.next()) &#123; System.out.println(rs.getInt(1) + "\t" + rs.getString(2) + "\t\t" + rs.getString(3) + "\t\t" + rs.getString(4)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3、程序执行结果 上面的程序中，使用了一条查询语句，查询表t_user的内容，执行程序后的结果如下图。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广度优先搜索 BFS算法]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[BFS算法的概念广度优先搜索算法（Breadth-First-Search，BFS），又称作宽度优先搜索。BFS算法是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。 算法思想 1、首先将根节点放入队列中。 2、从队列中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜索并回传结果。 否则将它所有尚未检验过的直接子节点加入队列中。 3、若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。 4、重复步骤2。 搜索过程演示 说明 灰色的是加入队列中的活动节点，黑色是从活动节点队列中选取的扩展节点。 每次将一个活动节点标记为扩展节点后，进行判断，并将该点从活动节点队列中移除，再将该节点所有未检测的子节点加入活动节点队列中去。 接下来再从队列中选取新的活动节点作为扩展节点，如此循环下去，直至队列为空为止，说明已经遍历过所有的节点。 复杂度 因为所有节点都必须被存储，因此BFS的空间复杂度为 O(|V|+|E|)，其中 |V| 是节点的数目，而 |E| 是图中边的数目。 最差情形下，BFS必须查找所有到可能节点的所有路径，因此其时间复杂度为 O(|V|+|E|)。 C++实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Given a binary tree, find its minimum depth.//The minimum depth is the number of nodes along //the shortest path from the root node down to //the nearest leaf node.// 递归方法class Solution &#123;public: int run(TreeNode *root) &#123; if (!root) &#123; return 0; &#125; // 若左子树为空，返回右子树深度 + 1 if (root-&gt;left == nullptr) &#123; return (run(root-&gt;right) + 1); &#125; // 若右子树为空，返回左子树深度 + 1 if (root-&gt;right == nullptr) &#123; return (run(root-&gt;left) + 1); &#125; // 左右子树都不为空，返回较小值 int leftDepth = run(root-&gt;left); int rightDepth = run(root-&gt;right); return ((leftDepth &lt; rightDepth) ? (leftDepth + 1) : (rightDepth + 1)); &#125;&#125;;// BFS方法#include &lt;vector&gt;using namespace std;class Solution&#123;public: int run(TreeNode *root) &#123; if (!root) &#123; return 0; &#125; vector &lt;TreeNode *&gt; que; TreeNode *now = root; // 当前访问的节点 TreeNode *last = root; // 每层最后的一个节点 que.push_back(root); int depth = 1; // 初始深度 while (que.size()) &#123; // 取出队列中的第一个节点作为当前节点 now = que.front(); que.erase(que.begin()); // 如果当前节点没有子节点了，直接终止循环，说明是叶子节点，返回最小深度 if ((now-&gt;left == nullptr) &amp;&amp; (now-&gt;right == nullptr)) &#123; break; &#125; // 将子节点加入队列中 if (now-&gt;left != nullptr) &#123; que.push_back(now-&gt;left); &#125; if (now-&gt;right != nullptr) &#123; que.push_back(now-&gt;right); &#125; // 当访问到每层的最后一个节点时，深度+1 if (now == last) &#123; depth++; last = que.back(); // 将下一层最后一个节点赋给last &#125; &#125; return depth; &#125;&#125;; BFS代表性应用 MTK编程挑战赛决赛《算术迷宫》 References 深度优先搜索 - 维基百科，自由的百科全书 算法入门 广度/宽度优先搜索(BFS) - CSDN博客 Algorithms: Graph Search, DFS and BFS - YouTube]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[麻将胡牌算法及代码实现]]></title>
    <url>%2F2018%2F07%2F29%2F%E9%BA%BB%E5%B0%86%E8%83%A1%E7%89%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[麻将的玩法规则麻将的玩法规则众多，核心的玩法是一致的，本文将根据联发科2017年编程挑战赛的复赛题规则来实现。 牌的表示方式 ABCDEFGHI代表一到九萬，abcdefghi代表一到九条，123456789代表一到九饼 三种胡牌牌型 普通牌型，14张牌，形如：3+3+3+3+2。其中数字2代表两张相同的牌可成一组，形如XX。数字3代表三张相同或者连续的牌可成一组，形如XXX、XYZ。 龙七对，14张形如：2+2+2+2+2+2+2。 带杠，即普通牌型里三张一样的牌XXX可以升级成XXXX，称为一道杠。每多一道杠，牌总数可以增加一张。最多可以有4道杠，因此带杠的胡牌，牌总数最多可以达18张。 样例 ABCeee345456DD 胡牌，组牌方式为 ABC+eee+345+456+DD，普通牌型。 ABeeee345456DD 炸胡，因为AB两张牌未能形成组牌。 AAAABC123456333 炸胡，虽然看似组牌OK（AAA+ABC+124+345+456+333）但是不符合任何一种胡牌牌型。 AADDFF1133aagg 胡牌，暗七对。 AAAABBBBCCCCDDDD88 胡牌，3+3+3+3+2牌型，升级了4道杠。 AAA123789 炸胡，不符合任何一种牌型。 AAA111345666DEF88 炸胡，不符合任何一种牌型。 算法实现思路 1、普通牌型为3n+2的形式，和龙7对均为14张牌，若有杠则最多有18张牌，因此第一步可以判定，如果牌数小于14或者大于18，则必定不能胡牌； 2、对牌进行从小到大排序，方便后续判断。如果手牌数是14张，可以先判定是否是龙7对(对对胡)，其特点是每张奇数位的牌都和它后一位的牌相等。如果不是对对胡，则进入步骤3； 3、3n+2形式的普通牌型里面有一个对子，因此判断是不是胡牌牌型，可以先找出其中的一个对子。一张牌可能有2张也可能有4张，可以组成对子也可能组成暗杠或者杠，又或者是和后面的牌组成顺子。不管情况有多少种，对子一定是出现在重复的牌之中，只要每次遍历去除一个对子即可。接下来进入步骤4； 4、去除一个对子后，判定是否是3n牌型，即是否是全部由顺子或者暗杠组成。由于牌已经经过排序，所以只要观察第一张牌即可。 如果第一张牌的数量只有一张或者两张，则这张牌必须和后面的牌组成顺子，否则不能胡牌。如果存在这样的顺子，去除这个顺子 如果第一张牌的数量有三张或者四张，则可能组成一个暗杠，或者是和后面的牌组成顺子（先不考虑有杠的情况），去除这个暗杠（顺子） 一直循环以上的判断，满足条件则去掉这三张牌，直到牌数为0时，返回“胡牌”，否则回到步骤3中，将之前去除的对子放回，继续删除下一个对子。如果步骤3中尝试过所有的对子还没能满足胡牌条件时，则返回“不胡牌”； 5、如果牌数为15张，则至少包含一个4张牌的杠，否则不胡牌。如果包含多个杠，则依次遍历删除一个杠，再进入步骤3，判断是不是3n牌型。如果遍历完所有的杠后还不能胡牌，则返回“不胡牌”； 6、如果牌数是16张，则至少包含2个杠，依次遍历删一对杠的组合，余下同步骤5类似。同理，牌数为17张和18张时方法类似。 C++源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using std::vector;using std::cout;template &lt;typename T&gt;void showVector(vector &lt;T&gt; &amp; lst);vector &lt;int&gt; findReptPos(vector &lt;char&gt; &amp; lst);bool isDDH(const vector &lt;char&gt; &amp; lst);bool isHU3N(vector &lt;char&gt; &amp; lst);vector &lt;char&gt; delDUI(const vector &lt;char&gt; &amp; lst, const int x);bool is3N(vector &lt;char&gt; lst);int numOfFirst(vector &lt;char&gt; lst);bool checkGroup(vector &lt;char&gt; lst, const int num);void delGroup(vector &lt;char&gt; &amp; lst, const int num);vector &lt;char&gt; delGANG(const vector &lt;char&gt; &amp; lst, const int x);vector &lt;int&gt; findGangPos(const vector &lt;char&gt; &amp; lst);int main(int argc, char **argv)&#123; char *mahjong = argv[1]; vector &lt;char&gt; lst; for (int i = 0; mahjong[i] != '\0'; ++i) &#123; lst.push_back(mahjong[i]); &#125; std::sort(lst.begin(), lst.end()); // 从小到大排序 /*cout &lt;&lt; "sort: "; showVector(lst);*/ int num = lst.size(); // 麻将牌数量 if ((num &lt; 14) || (num &gt; 18)) &#123; cout &lt;&lt; "BAD"; return 0; &#125; if (num == 14) // 14张牌，2种胡牌法 &#123; if (isDDH(lst)) // 如果是对对胡 &#123; cout &lt;&lt; "GOOD"; return 0; &#125; if (isHU3N(lst)) &#123; cout &lt;&lt; "GOOD"; &#125; else &#123; cout &lt;&lt; "BAD"; &#125; return 0; &#125; if (num == 15) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() &lt; 1) &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 依次删除一个杠，再判断是否是3N牌型 for (int i = 0; i &lt; pos.size(); ++i) &#123; vector &lt;char&gt; newLst = delGANG(lst, pos[i]); /*cout &lt;&lt; "delGANG/"; showVector(newLst);*/ if (isHU3N(newLst)) &#123; cout &lt;&lt; "GOOD"; return 0; &#125; &#125; cout &lt;&lt; "BAD"; &#125; &#125; if (num == 16) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() &lt; 2) // 少于2个杠肯定不胡牌 &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 依次删除不同的2个杠组合,再判断是否是3N牌型 for (int i = 0; i &lt; pos.size() - 1; ++i) &#123; for (int j = i + 1; j &lt; pos.size(); ++j) &#123; // 注意先删除后一个杠，否则位置会变动 vector &lt;char&gt; newLst1 = delGANG(lst, pos[j]); vector &lt;char&gt; newLst2 = delGANG(newLst1, pos[i]); /*cout &lt;&lt; "delGANG/"; showVector(newLst2);*/ if (isHU3N(newLst2)) &#123; cout &lt;&lt; "GOOD"; return 0; &#125; &#125; &#125; cout &lt;&lt; "BAD"; &#125; &#125; if (num == 17) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() &lt; 3) // 少于3个杠肯定不胡牌 &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 依次删除不同的3个杠组合,再判断是否是3N牌型 for (int i = 0; i &lt; pos.size() - 2; ++i) &#123; for (int j = i + 1; j &lt; pos.size() - 1; ++j) &#123; for (int k = j + 1; k &lt; pos.size(); ++k) &#123; // 注意先删除后一个杠，否则位置会变动 vector &lt;char&gt; newLst1 = delGANG(lst, pos[k]); vector &lt;char&gt; newLst2 = delGANG(newLst1, pos[j]); vector &lt;char&gt; newLst3 = delGANG(newLst2, pos[i]); /*cout &lt;&lt; "delGANG/"; showVector(newLst3);*/ if (isHU3N(newLst3)) &#123; cout &lt;&lt; "GOOD"; return 0; &#125; &#125; &#125; &#125; cout &lt;&lt; "BAD"; &#125; &#125; if (num == 18) &#123; vector &lt;int&gt; pos = findGangPos(lst); // 查找杠的位置 if (pos.size() != 4) // 不是4个杠肯定不胡牌 &#123; cout &lt;&lt; "BAD"; &#125; else &#123; // 直接删除4个杠 vector &lt;char&gt; newLst1 = delGANG(lst, pos[3]); vector &lt;char&gt; newLst2 = delGANG(newLst1, pos[2]); vector &lt;char&gt; newLst3 = delGANG(newLst2, pos[1]); vector &lt;char&gt; newLst4 = delGANG(newLst3, pos[0]); /*cout &lt;&lt; "delGANG/"; showVector(newLst4);*/ if (newLst4[0] == newLst4[1]) &#123; cout &lt;&lt; "GOOD"; &#125; else &#123; cout &lt;&lt; "BAD"; &#125; &#125; &#125; return 0;&#125;// 显示列表内容template &lt;typename T&gt;void showVector(vector &lt;T&gt; &amp; lst)&#123; vector &lt;T&gt;::iterator iter; // 迭代器 for (iter = lst.begin(); iter != lst.end(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "\n";&#125;// 查找重复牌的位置vector &lt;int&gt; findReptPos(vector &lt;char&gt; &amp; lst)&#123; vector &lt;int&gt; pos; // 储存重复牌的位置 int temp_pos = 0; if (lst.size() &lt;= 1) // 牌数小于等于1，直接返回 &#123; return pos; &#125; // lst.size() &gt;= 2 vector &lt;char&gt;::iterator iter2; iter2 = lst.begin(); ++iter2; // 迭代器不支持算数运算,只能++/--/advance链式操作 if (lst.front() == *iter2) &#123; pos.push_back(temp_pos); &#125; vector &lt;char&gt;::iterator it_front; vector &lt;char&gt;::iterator it_back; for (auto iter1 = iter2; iter1 != (--lst.end()); iter1++) // 从第二位到倒数第二位 &#123; ++temp_pos; // 位置更新 it_front = iter1; --it_front; it_back = iter1; ++it_back; // 不等于前面的且等于后面的 if ((*iter1 != *it_front) &amp;&amp; (*iter1 == *it_back)) &#123; pos.push_back(temp_pos); &#125; &#125; return pos;&#125;// 是否是对对胡bool isDDH(const vector &lt;char&gt; &amp; lst)&#123; vector &lt;char&gt; newLst = lst; for (int i = 0; i &lt;= 12; ++i) &#123; if (newLst[i] != newLst[i + 1]) &#123; return false; &#125; ++i; &#125; return true;&#125;// 是否是普通牌型3nbool isHU3N(vector &lt;char&gt; &amp; lst)&#123; vector &lt;int&gt; pos = findReptPos(lst); // 找重复牌的位置 for (int i = 0; i &lt; pos.size(); ++i) // 依次去掉重复的对子 &#123; vector &lt;char&gt; newLst = delDUI(lst, pos[i]); // 删除一对牌 /*cout &lt;&lt; "delDUI/"; showVector(newLst);*/ if (is3N(newLst)) &#123; return true; &#125; &#125; return false;&#125;// 是否是N个顺子或者暗杠bool is3N(vector &lt;char&gt; lst)&#123; if (lst.size() % 3 != 0) &#123; return false; &#125; while (lst.size() &gt; 0) &#123; if (lst.size() &gt;= 3) &#123; int num = numOfFirst(lst); // 计算第一张牌的重复数量 if (checkGroup(lst, num)) // 检查是否有第一个顺子或者暗杠 &#123; delGroup(lst, num); // 删除这组顺子或者暗杠 &#125; else &#123; return false; &#125; &#125; /*cout &lt;&lt; "//"; showVector(lst);*/ &#125; return true;&#125;// 检查是否有第一个顺子或者暗杠bool checkGroup(vector &lt;char&gt; lst, const int num)&#123; if ((num == 1) &amp;&amp; (lst[1] == lst[0] + 1)) &#123; // 第二个数可能有重复情况 for (int i = 2; i &lt; lst.size(); ++i) &#123; if (lst[i] != lst[1]) &#123; if (lst[i] == lst[0] + 2) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; if ((num == 2) &amp;&amp; (lst[2] == lst[1] + 1)) &#123; // 第三个数可能有重复情况 for (int i = 3; i &lt; lst.size(); ++i) &#123; if (lst[i] != lst[2]) &#123; if (lst[i] == lst[1] + 2) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; if (num &gt;= 3) &#123; return true; &#125; return false;&#125;// 删除这组顺子或者暗杠void delGroup(vector &lt;char&gt; &amp; lst, const int num)&#123; if (num == 1) &#123; vector &lt;char&gt;::iterator iter = ++lst.begin(); for (int i = 2; i &lt; lst.size(); ++i) &#123; ++iter; if (lst[i] == (1 + lst[1])) &#123; lst.erase(iter); lst.erase(lst.begin()); lst.erase(lst.begin()); break; &#125; &#125; &#125; if (num == 2) &#123; vector &lt;char&gt;::iterator iter = ++(++lst.begin()); for (int i = 3; i &lt; lst.size(); ++i) &#123; ++iter; if (lst[i] == (1 + lst[2])) &#123; lst.erase(iter); lst.erase(++lst.begin()); // 删除第二位的牌 lst.erase(++lst.begin()); break; &#125; &#125; &#125; if (num &gt;= 3) &#123; lst.erase(lst.begin()); lst.erase(lst.begin()); lst.erase(lst.begin()); &#125;&#125;// 计算第一张牌的重复数量int numOfFirst(vector &lt;char&gt; lst)&#123; if (lst[0] != lst[1]) &#123; return 1; &#125; if ((lst[0] == lst[1]) &amp;&amp; (lst[1] != lst[2])) &#123; return 2; &#125; if (lst[0] == lst[2]) &#123; if (lst.size() == 3) &#123; return 3; &#125; if ((lst.size() &gt;= 4) &amp;&amp; (lst[2] != lst[3])) // lst[3]一定保证size&gt;=4 &#123; return 3; &#125; &#125; if ((lst[0] == lst[3]) &amp;&amp; (lst.size() &gt;= 4)) &#123; return 4; &#125; return 0;&#125;// 删除x和x+1位置的一对牌vector &lt;char&gt; delDUI(const vector &lt;char&gt; &amp; lst, const int x)&#123; vector &lt;char&gt; newLst; for (int i = 0; i &lt; lst.size(); ++i) &#123; if ((i != x) &amp;&amp; (i != (x + 1))) &#123; newLst.push_back(lst[i]); &#125; &#125; return newLst;&#125;// 删除起始位置为x的杠（4张牌）vector &lt;char&gt; delGANG(const vector &lt;char&gt; &amp; lst, const int x)&#123; vector &lt;char&gt; newLst; for (int i = 0; i &lt; lst.size(); ++i) &#123; if ((i &lt; x) || (i &gt; x + 3)) &#123; newLst.push_back(lst[i]); &#125; &#125; return newLst;&#125;// 查找杠的位置vector &lt;int&gt; findGangPos(const vector &lt;char&gt; &amp; lst)&#123; vector &lt;int&gt; pos; int temp_pos = 0; if (lst.size() &lt; 4) &#123; return pos; &#125; for (int i = 0; i &lt; lst.size() - 3; ++i) &#123; if (lst[i] == lst[i + 3]) &#123; pos.push_back(temp_pos); &#125; ++temp_pos; // 位置更新 &#125; return pos;&#125; 程序运行结果 程序从命令行参数取得输入数据，数据为一个字符串，代表一副牌。若这副牌达到胡牌条件，输出GOOD，否则输出BAD。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB常用指令记录]]></title>
    <url>%2F2018%2F06%2F27%2FMATLAB%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[123456789help + &apos;command name&apos; % 查询指令用法 Ctrl + Break % 强制终止程序运行Shift + Enter % command window下换行不运行指令M&apos;; % 复数的共轭，矩阵的转置inv() % 矩阵的逆det() % 矩阵的行列式值rank() % 求出矩阵的秩n = norm(X,p) % 求矩阵的p范数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990clear all；clc； % 清除工作空间，清空command window记录set(0,'defaultfigurecolor','w'); % 设置figure背景为白色X = zeros(n) % Create a n-by-n array of 0X = zeros(sz1,...,szN) % Create a sz1-...-szN array of 0X = ones(sz1,...,szN); % Create a sz1-...-szN array of 1I = eye(n); % Create a n-by-n identity identity matrixr = rand(sz1,...,szN); % 产生一个均匀分布的伪随机数矩阵r = randn(sz1,...,szN); % 产生一个标准正态分布的伪随机数矩阵r = randi([imin,imax], sz1,...,szN); % 产生一个区间内均匀分布的伪随机整数矩阵y = awgn(x,snr) % 给信号x添加add一个snr（dB）的高斯白噪声y = wgn(m,n,p) % 产生一个p（dBm）的高斯白噪声R = normrnd(mu,sigma,m,n,...) %产生均值mu 标准差sigma的正态分布矩阵seq = normrnd(mean, sigma, sz1, sz2) % 产生指定均值方差的正态分布的序列seq = randperm(n) % 产生乱序序列B = reshape(A,[m n])； % returns the m-by-n matrix B according Alength() % 返回矩阵最长维的的长度size() % 返回每一维的长度blkdiag(A, B) % 以A，和B为块创建块对角矩阵A(index, :, :) = [ ] % 空赋值，等效于删掉某行某列abs(); % 取绝对值/模angle(); % 取角度log2(n); % log以2为底取对数exp(); % 指数sqrt(); % 开方sind(theta); % theta为角度sin(theta); % theta为弧度% 计时器，结束时显示过程时间tic...toc% 进度条hWait = waitbar(0,'Please wait...');steps = 1000;for step = 1:steps % computations take place here waitbar(step / steps);endclose(hWait); load/save('filename，'variable') % 载入/存储变量值到mat文件find(X) % 查找某个值 返回索引data == X % 返回对应长度的布尔型矩阵disp('数据');disp(data); % 显示字符或变量值figure; % 创建新的figureset(0,'DefaultFigureProperty',PropertyValue...); % 设置figure默认参数属性plot(X,Y); % 绘制曲线图=============================================================== 颜色 线型--------------------------------------------------------------- y 黄色 . 圆点线 v 向下箭头 g 绿色 -. 组合 &gt; 向右箭头 b 蓝色 + 点为加号形 &lt; 向左箭头 m 红紫色 o 空心圆形 p 五角星形 c 蓝紫色 * 星号 h 六角星形 w 白色 . 实心小点 - 实线 r 红色 x 叉号形状 ^ 向上箭头 k 黑色 s 方形 d 菱形 -- 虚线 ===============================================================subplot(m,n,p); % 平铺figure为m行n列，指定当前figure为第p个polar(theta,rho) % 绘制极坐标图，theta,rho分别是向量contour(X, Y, Z) % 绘制等高线图mesh(X, Y, Z) % 绘制三维图scatter(X,Y) % 绘制散点图bar(X, Y, width, color) % 绘制柱状图（竖直）% 居中添加文本字符串text(pos_x, pos_y, num2str(data), 'VerticalAlignment', 'middle', 'HorizontalAlignment', 'center')set(gca, 'Fontname', '微软雅黑');xlabel('---', 'Fontname', '微软雅黑'); % 设置x轴标号样式set(gca,'xticklabel', &#123;'str1','str2','str2',...) % 设置x轴横轴标号title('---', 'Fontname', '微软雅黑'); % 设置标题样式axis([xMin xMax yMin yMax]); % 控制坐标显示范围axis tight; % 控制显示范围在数据区域grid on; % 开启网格]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法求图的直径并记录路径]]></title>
    <url>%2F2018%2F06%2F24%2FFloyd%E7%AE%97%E6%B3%95%E6%B1%82%E5%9B%BE%E7%9A%84%E7%9B%B4%E5%BE%84%E5%B9%B6%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[相关概念 对于一个图G=(V, E)，求图中两点u， v间最短路径长度，称为图的最短路径问题。最短路径中最长的称为图的直径。 其中，求图中确定的某两点的最短路径算法，称为单源最短路径算法。求图中任意两点间的最短路径算法，称为多源最短路径算法。 常用的路径算法有 Dijkstra算法 SPFA算法\Bellman-Ford算法 Floyd算法\Floyd-Warshall算法 Johnson算法 其中最经典的是Dijkstra算法和Floyd算法。Floyd算法是多源最短路径算法，可以直接求出图中任意两点间的距离，因此只要取其中最大的就可以得到图的直径。 Floyd算法算法思想假设Dis(i,j)为节点u到节点v的最短路径的距离(最短路径长度)，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，说明从i到k再到j的路径比i直接到j的路径短，便记录Dis(i,j) = Dis(i,k) + Dis(k,j)。因此，当遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。 算法特点 使用了动态规划思想 可以计算无向图或有向图 核心代码简短(五行) 可以一次性计算出任意两点间的距离 算法复杂度O(n^3)，是一个好算法 一个关键性问题在判断Dis(i,k) + Dis(k,j) &lt; Dis(i,j)这个公式时，如果经过k的距离更短就选择k，但是这能否保证此时Dis(i,k)和Dis(k,j)已经取得了最小值呢？ 答案是肯定的，可以用数学归纳法证明，参考这篇博客 示例待求直径的图G 程序输入2（表示无向图） 8 9 （表示8个顶点，9条边） 1 2 5 （表示顶点1和顶点2之间的距离权重是5） … … 程序输出（邻接矩阵，矩阵元素M[i][j]表示顶点Vi与Vj间的距离） （各个顶点间的最短路径以及路径长度，对于此例，顶点V4与V6或V8间的距离都是10，是距离最远的两个顶点对） （此图的直径） Python源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# ----------------------------------------------# Project： calculate diameter of graph# Using floyd algorithm# ----------------------------------------------# define function: print shortest pathdef getPath(i, j): if i != j: if path[i][j] == -1: print('-', j+1, end='') else: getPath(i, path[i][j]) getPath(path[i][j], j)def printPath(i, j): print(' Path:', i+1, end='') getPath(i, j) print()print('---------------- Program start ----------------')# read dataflag = input('please input type of graph(1:directed ' 'graph; 2:undirected graph): ')vertex, edge = input('please input the number of ' 'vertex and edge: ').strip().split()# initializedflag = int(flag)vertex = int(vertex)edge = int(edge)inf = 99999999dis = [] # matrix of the shortest distancepath = [] # record the shortest pathfor i in range(vertex): dis += [[]] for j in range(vertex): if i == j: dis[i].append(0) else: dis[i].append(inf)for i in range(vertex): path += [[]] for j in range(vertex): path[i].append(-1)# read weight informationprint('please input weight info(v1 v2 w[v1,v2]): ')for i in range(edge): u, v, w = input().strip().split() u, v, w = int(u)-1, int(v)-1, int(w) if flag == 1: dis[u][v] = w elif flag == 2: dis[u][v] = w dis[v][u] = wprint('the weight matrix is:')for i in range(vertex): for j in range(vertex): if dis[i][j] != inf: print('%5d' % dis[i][j], end='') else: print('%5s' % '∞', end='') print()# floyd algorithmfor k in range(vertex): for i in range(vertex): for j in range(vertex): if dis[i][j] &gt; dis[i][k] + dis[k][j]: dis[i][j] = dis[i][k] + dis[k][j] path[i][j] = kprint('===========================================')# output the resultprint('output the result:')if flag == 1: for i in range(vertex): for j in range(vertex): if (i != j) and (dis[i][j] != inf): print('v%d ----&gt; v%d tol_weight:' '%3d' % (i+1, j+1, dis[i][j])) printPath(i, j) if (i != j) and (dis[i][j] == inf): print('v%d ----&gt; v%d tol_weight:' ' ∞' % (i+1, j+1)) printPath(i, j)if flag == 2: for i in range(vertex): for j in range(i+1, vertex): print('v%d &lt;----&gt; v%d tol_weight:' '%3d' % (i+1, j+1, dis[i][j]), '', end='') printPath(i, j)print()for i in range(vertex): for j in range(vertex): if dis[i][j] == inf: dis[i][j] = 0# max(max(dis)): the max item of two dimension matrixprint('&gt;&gt; the diameter of graph: %d &lt;&lt;' % max(max(dis)))print('-------------- Program end ----------------') Reference 最短路径_百度百科 最短路径—Dijkstra算法和Floyd算法 最短路径问题—Floyd算法详解 - CSDN博客 Floyd算法(记录路径) - CSDN博客]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab更换字体后 中文显示乱码问题]]></title>
    <url>%2F2018%2F06%2F21%2FMATLAB%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93%E5%90%8E%20%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言MATLAB的脚本代码默认宋体显示，对于大多数720P的显示器来说，无论是中文还是英文，显示效果都非常差。Windows环境下，Consolas是一种比较理想的英文代码字体。 Consolas 字体是微软专为程序员开发的一种字体，这一字体的特性是所有字母、数字与符号均能非常容易辨认!而且所有字符都具有相同的宽度,让编程人员看着更舒适。但是不支持中文。 微软雅黑是个人电脑上可以显示的最清晰的中文字体之一,全面支持ClearType技术。 但是在MATLAB 2014b中将默认字体设置修改后，中文注释会出现乱码。解决方案是下载一种 Consolas 和 微软雅黑 的混合字体，这样既保证了代码的显示效果，而且也兼容了中文显示。 解决方案1、下载雅黑Consolas字体混合版 下载链接YAHEI CONSOLAS HYBRID.TTF 2、安装字体 下载后，双击，然后安装字体。 C:\Windows\Fonts文件夹下会出现刚刚安装成功的字体。 3、更改MATLAB的字体设置 打开MATLAB设置项。 然后选择新安装的字体，保存设置 4、查看效果 测试效果，发现中英文皆可正常显示。 Reference matlab字体终极解决方案 - CSDN博客 YaHei Consolas Hybrid(雅黑Consolas字体混合版) v1.12最新版 - 未来软件园]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
</search>
